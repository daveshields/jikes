<html>
<head>
<title>Jikes FAQ</title>
</head>
<BODY BGCOLOR="#FFFFFF">
<IMG SRC="jikes.gif" WIDTH=600 HEIGHT=54 HSPACE=0 VSPACE=0 BORDER=0 ALIGN="top">

<h2 align="center">The Jikes Project</h2>
<h2 align="center">
<A HREF="http://oss.software.ibm.com/developerworks/opensource/jikes/project">
http://oss.software.ibm.com/developerworks/opensource/jikes/project</A></h2>
<h2 align="center">Frequently Asked Questions About Jikes</h2>
<h2 align="center">August 1, 2000</h2>
<p>
<h2>About Jikes</h2>

<p><br>
<a href="#what_is"><b>What is Jikes?</b></a> <br>
<a href="#usage"><b>How do I use it? What options does it support?</b></a><br>
<a href="#jikespath"><b>Why must I define <code>CLASSPATH</code>? What is <code>JIKESPATH</code>?</b></a><br>
<a href="#listing"><b>How do I control the compiler listing?</b></a><br>
<a href="#incremental"><b>What is incremental compilation?</b></a><br>
<a href="#make"><b>How do I use Jikes to generate dependencies for make?</b></a><br>
<a href="#compatible"><b>
Why does Jikes reject a program that another compiler accepts, or accept one that it rejects?</b></a><br>
<a href="#results"><b>
What can I do if I don't get the same results when using class files generated by Jikes?</b></a><br>
<a href="#bugs"><b>How do I report bugs?</b></a>
<h2>About Jikes Source</h2>
<p>
<a href="#whyis"><b>Why did IBM Research make the source available?</b></a><br>
<a href="#whatcanido"><b>What can I do with the source?</b></a><br>
<a href="#build"><b>How do I compile the source?</b></a><br>
<a href="#test"><b>How do I test the compiler?</b></a><br>

<h3><a name="what_is"><b>What is Jikes?
</b></a></h3>

<p>
Jikes is a compiler that translates Java source files as
defined in
<a href="http://www.java.sun.com/docs/books/jls">
The Java Language Specification</a>
into the bytecoded instruction set and binary format defined in
<a href="http://www.java.sun.com/docs/books/vmspec">
The Java Virtual Machine Specification</a>.

<p>You may wonder why the world needs another Java compiler,
considering that Sun provides javac free with its JDK. Jikes has four
advantages that make it a valuable contribution to the Linux and Java
communities:</p>

<UL>

<LI>

<b>Open source</b>. Anyone can freely acquire the source code to
Jikes and redistribute it, possibly with modifications.  This allows
Jikes to reap the maximum benefit possible from the developer
community, and has already resulted in Jikes being ported to several
platforms.  In an equally important sense of openness, the Jikes team
-- which includes members of several organizations besides IBM -- is
eager to accept bug reports, suggestions, and changes from the
community. Open source is good, but open source from a receptive
development team is better.

<LI>

<b>Strictly Java compatible</b>. Jikes adheres to both The Java
Language Specification and The Java Virtual Machine Specification as
tightly as possible, and does not support subsets, supersets, or
other variations of the language. This document describes
some of the side effects of this strict language conformance, as well
as links to dozens of issues the Jikes development team has raised
with Sun regarding the interpretation of the specification.</P>

<LI>

<b>High performance</b>. Jikes is a high-performance compiler, making
it ideal for use with larger projects. Compilation speed, like RAM
and hard disk space, is one of those commodities you can't get enough
of on development projects. Jikes provides noticeably higher
performance for large compilations.</P>

<LI>

<b>Dependency analysis</b>. Jikes performs a dependency analysis on
your code that provides two very useful features: Incremental builds
and makefile generation. The incremental build feature is started by
using the "++" command line option, as in: <code>jikes
++ myprog.java</code>

<p>This will compile <code>myprog.java</code> and other files, as
needed, and leave Jikes running. You can then change <code>myprog.java</code>
or any of the source files it depends on. Then, you simply hit enter at
the command line to tell Jikes to re-check the dependencies and only
recompile files as required to bring the entire project up to date.
Jikes will stay in this "hit enter/rebuild" loop until you enter a
<code>q</code>, which tells it to terminate.</p>

<P>The makefile generation feature is invoked with the +M
command-line option, as in: <code>jikes +M myprog.java</code>.

<p>This tells Jikes to perform full dependency checking on
<code>myprog.java</code> and create a file that lists the
dependencies for each <code>.class</code> file that will be created
by the compiler. By default this file has the same filename as the
source file, with an extension of <code>u</code>.  For example, the
dependency file for <code>myprog.java</code> would be
<code>myprog.u</code>.

</ul>

<p>It's worth pointing out that Jikes is not, and is not intended to
be, a complete development environment -- it is simply a command-line
compiler. It shouldn't be considered a replacement for more complete
tools, such as IBM's VisualAge for Java, which provides a
sophisticated graphical IDE (integrated development environment) and
offers the option of compiling Java to native binary code as well as
<code>.class</code> files.


<p>Increasingly, one of the easiest ways to get Jikes for Linux is
with Linux itself -- Jikes is included in the
<a href="http://debian.org">Debian</a>,
<a href="http://www.freebsd.org/">FreeBSD</a>,
<a href="http://www.linux-mandrake.com">Mandrake-Linux</a>,
<a href="http://redhat.com">Red Hat</a>,
<a href="http://linuxppc.com/">Linux PPC</a>,
and
<a href="http://www.suse.com/">SuSE</a>
distributions.

<P>The source code for Jikes is available under IBM's Public License, which has
been approved by the
<a href="http://www.opensource.org">OSI</a> (Open Source Initiative) as
a fully compliant open source license. The most
recent stable release will be made available for download
from the <A href="http://oss.software.ibm.com/developerworks/opensource/jikes/project/">
Jikes project homepage</A>. CVS access to the most recent
sources is also provided, the CVS info is as follows:
<p>
<pre>
<code>
setenv CVSROOT :pserver:anoncvs@CVS.Sourcery.Org:/cvs/jikes

cvs login
(pasword is anoncvs)

cvs checkout jikes
</code>
</pre>

<P>The fact that Jikes is a high-performance, highly compatible Java
compiler that can be used on almost any computing platform makes it
an interesting program and worth investigating for almost any Java
programmer. But Jikes is also notable because it lies at the center
of two events: the adoption of open source philosophy and practice by
large corporations, and the continued growth of Java for Linux.</p>


<p>
In addition to the source code for the Jikes compiler, we also provide the source for JIKESPG, the parser generator
used in part to build Jikes, and a test suite.

<p>See
 <a href="http://oss.software.ibm.com/developerworks/opensource/jikes/project/news.html">
Jikes News</a> for news of recent developments.

<p>See <a href="ports.html">ports</a> for a list of known ports--usually
the work of an individual -- to other systems; some of the authors of
these ports also provide binary versions.

<p>
Jikes users and developers communicate using the
Jikes
<a href="http://oss.software.ibm.com/developerworks/opensource/jikes/project/subscribe.html">mailing lists</a>.

<p>

The original version of Jikes, first released in binary form in April
1997, was written by Philippe Charles and Dave Shields of the IBM T.
J. Watson Research Center.  Since the release of the source in
December 1998 they have continued work on the compiler as
contributors.

<p>
Here are links to some of the articles in the press that have mentioned Jikes:
<p>
PC Week (December 1998): 
<a href="http://www.zdnet.com/pcweek/stories/news/0,4153,375509,00.html">
Jikes! More open source code.</a>
<br>
Javaworld (December 1998): 
<a href="http://www.javaworld.com/pr/awards98.html#1">
JavaWorld announces finalists in its 1998 Editor's Choice Awards.</a>
<br>
Computing (April 1998): 
<a href="http://www.zdnet.com/products/content/zdim/0304/288352.html"> 
Internet Java Tools Enrich the Bean Pool.</a>
<br>
PC Week (December 1997): <a href="http://www.zdnet.com/pcweek/sr/1222/22prod97.html">
PCW Labs' top 10 tech trends: It was the best of information technology.</a>
<br>
PC Week (September 1997):  
<a href="http://www.pcweek.com/news/0922/22tech.html">
IBM spreading its software wings.</a>
<br>
Infoworld (May 1997): 
<a href="http://www.haifa.il.ibm.com/webcutter/infoworld/infoworld24May.html">
IBM to invest $100 million in Internet, networking research center this year.</a>
<br>
Web Week (April 1997): 
<a href="http://www.webweek.com/97Apr28/software/rails.html">
IBM Greases Java's Rails.</a>
<br>
PC Week (April 1997): 
<a href="http://www.pcweek.com/news/0414/14ante.html">
IBM, Netscape Up Web Ante.</a>


<h3><a name="usage"><b>How do I use it? What options does it
support?</b></a></h3>

<p>Invoke Jikes in the form:
<pre>
    jikes options filename...
</pre>

Invoke Jikes with no arguments to see a short summary of the
arguments. Allowed options are:


<dl>
    <dt><code>-classpath path</code> </dt>
    <dd>Set classpath.</dd>
    <dt><code>-d dir</code></dt>
    <dd>Write class files in specified directory.</dd>
    <dt><code>-debug</code> </dt>
    <dd>No effect (recognized for compatibility with many compilers).
    </dd>
    <dt><code>-depend</code> </dt>
    <dd>Recompile all used classes.
    </dd>
    <dt><code>-deprecation</code> </dt>
    <dd>Report on use of deprecated features.</dd>
    <dt><code>-g</code></dt>
    <dd>Generate <code>LocalVariableTable</code> attribute.
    </dd>
    <dt><code>-nowarn</code></dt>
    <dd>Suppress warning messages.</dd>
    <dt><code>-nowrite</code></dt>
    <dd>Do not write any class files.</dd>
    <dt><code>-O</code> </dt>
    <dd>Do not generate <code>LineNumberTable</code> attribute.</dd>
    <dt><code>-verbose</code></dt>
    <dd>List files read and written.</dd>
    <dt><code>-Xstdout</code></dt>
    <dd>Write error messages to standard output.</dd>
    <dt><code>++</code></dt>
    <dd>Compile in incremental mode.</dd>
    <dt><code>+B</code></dt>
    <dd>Do not generate bytecode. This is used primarily for debugging
        the compiler. <code>-nowrite</code> generates byte code but does
        not write it out.</dd>
    <dt><code>+CSO</code></dt>
    <dd>Select classpath search order. By default Jikes takes the first <code>class</code> or
	<code>java</code> file found. If <code>CSO</code> is specified the Jikes behaves more like
	<code>javac</code> searching all directories for a <code>class</code> or <code>java</code> file,
	and then comparing their dates to determine if a recompilation is necessary.
    <dt><code>+D</code></dt>
    <dd>List errors immediately in emacs-form without buffering. This is only needed if
    Jikes is crashing and you want to see errors as soon as they are detected; ordinarily
    errors are sorted and listed at the end of the compilation.</dd>
    <dt><code>+DR=filename</code></dt>
    <dd>Write report of dependencies to specified file.</dd>
    <dt><code>+E</code></dt>
    <dd>List errors in a form commonly used by <em>emacs</em> to
        scan for errors. By default errors are listed in a more readable
        form. </dd>
    <dt><code>+F</code></dt>
    <dd>Do full dependence check except for Zip and Jar files.</dd>
    <dt><code>+M</code></dt>
    <dd>Generate makefiles with dependencies.</dd>
    <dt><code>+P</code></dt>
    <dd>Generate pedantic listing.</dd>
    <dt><code>+Tnn</code></dt>
    <dd>Set tab width for listing error messages.</dd>
    <dt><code>+U</code></dt>
    <dd>Do full dependence check including Zip and Jar files.</dd>
    <dt><code>+Z</code></dt>
    <dd>Treat cautons as errors.</dd>
    
</dl>

<p>Jikes can be used to compile more than one file at a time, causing
a class file to be created for each Java source file. It is possible
that compilation of a file named early on in the argument list will
force the compilation of a file that is also named later on; however,
no file will be compiled more than once.  Jikes allows the same file
to be named more than once; however, such files are only compiled
once:
<pre>
        jikes Test.java x.java Test.java

</pre>

<p>Jikes also accepts arguments starting with an at-sign (@). Such
arguments are taken be the name of a file, each line of which is then
processed as though it were itself an argument, except that lines so
read that begin with an at-sign are not processed recursively. For
example, the above command could also be written as:
<pre>
        jikes @file.list
</pre>
where <code>file.list</code> is a file containing the lines:
<pre>
        Test.java
        x.java
        Test.java
</pre>

<h3><a name="jikespath"><b>

Why must I define <code>CLASSPATH</code>? What is <code>JIKESPATH</code>?
</b></a> </h3>

<p>You must have some version of the JDK or JRE to run Jikes, so the
compiler can access the standard class files.  Note that versions 1.1
of the JDK do not require that you provide a definition of
<code>CLASSPATH</code> to run <code>javac</code> and
<code>java</code>. However, Jikes doesn't know what version of the
JDK you are using and so must be told how to find the standard
library files. This can be done in three ways:
<ul>
<li>Provide a definition of <code>CLASSPATH</code>; for example, in Win95 this takes the form
<pre>
    SET CLASSPATH=.;C:\JAVA\LIB\CLASSES.ZIP
</pre>
or for example, in Linux:
<pre>
    export CLASSPATH=.:/usr/local/jdk.1.1.6/lib/classes.zip (jdk)
    export CLASSPATH=.:/usr/local/jre1.1.6/lib/rt.jar   (jre)
</pre>
</li>
<li>Always specify a value for the <code>-classpath</code> option on the command line;
for example:
<pre>
    jikes -classpath .:$HOME/java/lib/classes.zip ...
</pre>
</li>
<li>Use <code>JIKESPATH</code> as discussed below.
</ul>

<p>Jikes allows the use of <code>JAR</code> files, which have the
standard "zip" format, provided that any contained <code>class</code>
files are stored either using no compression or the default
"DeflatedN" compression (also known as "method 8" in zip-speak).
Indeed, any item in the class path that is a not a directory is
assumed to be a file in zip format.  The code used to do the the
uncompression is based on that used in <code>unzip532</code> from
Info-ZIP, so we have to make the following statement:
<blockquote>Jikes incorporates compression code from the Info-ZIP
   group. There are no extra charges or costs due to the use of
   this code, and the original compression sources are freely
   available from <a href="http://www.cdrom.com/pub/infozip/">Info-ZIP</a> or 
   <a href="ftp://ftp.cdrom.com/pub/infozip/">Info-ZIP ftp site</a> on the Internet.
</blockquote>

<p>Jikes looks for a definition of <code>JIKESPATH</code> in the
environment before it looks for a definition of
<code>CLASSPATH</code>. If <code>JIKESPATH</code> is defined, then
its value is used when looking for a class file.

<p>You should <em>almost always</em> include "." in the classpath;
omit it only if you understand the implications.

<p>The order in which the classpath is searched can also be selected using the
<code>CSO</code> (Classpath Search Order) option. By default,
<ul>
<li>Jikes searches the classpath from left to right.
<li>In a given directory, it finds the most recent <code>.java</code>
 or <code>.class</code> file.
<li>Jikes then uses the <code>.java/.class</code> found in the leftmost classpath entry for
compilation purposes
</ul>

<p>If the <code>CSO</code> option is specified, Jikes provides the same
behavior as <code>javac</code>:
<ul>
<li>Find the <code>.java</code> file which occurs leftmost in the classpath.
<li>Find the <code>.class</code> file which occurs leftmost in the classpath.
<li>Use the more recent of these for compilation purposes.
</ul>

<h3>
<a name="listing">
<b>
How do I control the compiler listing?
</b></a></h3>
Jikes does not produce a compiler listing in the usual sense, but only writes out cautions, warnings and errors.
<p>
A caution is more severe than a warning,
but normally does not prevent the writing of the class file. The <code>+Z</code> option can be used to prevent the writing of a class file if any cautions are detected.

<p>A number of options select the kind and volume of the information
produced. They are <code>-nowarn</code>, <code>-verbose</code>,
<code>+E</code> and <code>+P</code>. The first two are found in most
Java compilers: <code>-nowarn</code> requests that warning messages
not be written, <code>-verbose</code> requests a report on the files,
including source and class files, read and written by the compiler.

<p>The error kind option <code>+E</code> is used to select how error
messages are formatted, By default, error messages are written in a
long form with the part of the text the compiler is complaining about
underlined, and with detailed explanatory text. The <code>+E</code>
option requests a terser form, suitable for automatic parsing by
editors such as <a
href="http://www.gnu.org/software/emacs/emacs.html">
<code>emacs</code> </a>
and 
<a href="http://www.lugaru.com"><code>epsilon</code></a>. For example, consider the mis-typed "hello world" example:
<pre>
class hello {
   public static void main(String[] args) {
     system.out.println("hi there"); // should be System...
   }
}
</pre>
When <code>+E</code> is not used, the error is reported as
<pre>
Found 1 semantic error compiling "hello.java":

     3.      system.out.println("hi there"); // should be System...
             <-------->
*** Semantic Error: "system/out" is either a misplaced package name or a non-existent entity.

</pre>
With <code>+E</code> is used, the error is reported as:
<pre>
hello.java:3:6:3:15: Semantic:"system/out" is either a misplaced package name or a non-existent entity.
</pre>
The initial part of each line contains several fields, separated by colons, giving in order the file name, the starting line in the file, the starting column in the starting
line, the ending line, and the column number in the ending line.

<p> The pedantic option <code>+P</code> is used to request a
complete, pedantic listing.  Just what is or is not pedantic
depends in part on e-mail we have received in which users have noted
that Jikes complains about constructs that other compilers accept.
(It is an open question whether the other compilers choose not to
report this information, or whether they do not even discover it.)
Select this option for a detailed listing. Currently, the following are only reported if <code>+P</code> is selected:
<ul>
<li>No type declarations:
<pre>
   This compilation unit contains no type declaration
</pre>
</li>
<li>Empty declarations, typically the result of an extraneous semicolon:
<pre>
   An EmptyDeclaration is a deprecated feature that should not be used
</pre>
</li>
<li>Attempt to overwrite method with <code>private</code> access:
<pre>
    Note that the method ... in class ... does not override the corresponding 
    method with private access in class ...
</pre>
</li>
<li>Attempt to overwrite default method:
<pre>
    The method ... in class ... does not override the corresponding 
    method with default access in class ...
</pre>
</li>
<li>

Access to a type defined in unnamed package. This message is issued
in response to the comment in section 7.4.2 of the specification that
"It is recommended that a Java system provide safeguards against
unintended consequences in situations where compiliation units of
named packages import types from unnamed packages."
<pre>
   The type associated with this construct is (or depends on) the type ...
   which is contained in an unnamed package
</pre>
</li>
</ul>

<p>
We say <code>C</code> depends on <code>D</code> if and only if the constant pool for <code>C</code> contains a reference
 to <code>D</code>. 
Types so referenced may need to be incorporated into the compilation, either by reading their class file or 
compiling a source file
to produce the needed class file. Incorporation is done as follows:
<ul>
<li>
If there is no class file and there is a source file, then the source file is compiled.</li>
<li>
If there is no source file and there is a class file, then the class file is read.</li>
<li>
If both a class file and a source file exist, then the class file is read only if it is newer than the source file;
otherwise the source file is compiled.</li>
<li>
If there is no class file and no source file, an error is reported.</li>
</ul>
(The effect of the <code>-depend</code> option is to always compile a source file if there is one).

<p>
By default, Jikes does not incorporate <code>D</code> unless it must.

<p>
If <code>+F</code> is specified, and <code>C</code> does not belong to a Zip or Jar file, the type <code>D</code> is incorporated. Otherwise, D is
incorporated only if it must be.

<p>
If <code>+U</code> is specified, then <code>D</code> is always incorporated.

<p>
The option <code>+F</code> directs the compiler to load all other
types that are referenced within a class file, and causes
recompilation of such files if their source file is more up-to-date
than the class file.  Normally, other types are loaded only if
required for the current compilation.

<p> 
The option <code>-depend</code> (which can also be written
<code>-Xdepend</code>, for 1.2 compatibility) directs the compiler to
always compile a source file, if one exists, instead of loading its
class file, even if it exists and is up-to-date. 
<p>
Consider the following example:
<pre>
// file A.java:
class A {
  static public void main(String[] args) {
    System.out.println("enter A");
    B.message();
  }
}

// file B.java:
class B {
  static void message() {
    System.out.println("enter B");
    C.message();
  }
}

// file C.java:
class C {
  static void message() {
    System.out.println("enter C");
  }
}
</pre>

If no class files exist, then
<pre>
	jikes A.java
</pre>
results in compilation of <code>A</code>, <code>B</code> and <code>C</code>.
<p>
If <code>C.java</code> (but not <code>B.java</code>) is updated, then
<pre>
	jikes A.java
</pre>
results in compilation only of <code>A</code>. <code>javac</code> does the same thing.
<p>
However, if <code>C.java</code> (but not <code>B.java</code>) is updated, then
<pre>
	jikes +F A.java
</pre>
results in compilation of <code>A</code> and <code>C</code>.

It is always the case, independent of time-stamps of files, that
<pre>
	jikes -depend A.java
</pre>
results in compilation of <code>A</code>, <code>B</code> and <code>C</code>.
<p>
Note that 
<pre>
	jikes -depend +F ...
</pre>
has the same effect as
<pre>
	jikes -depend ...
</pre>
i.e., <code>+F</code> will cause no more files to be compiled than
will <code>-depend</code>.


<p>You can use <code>+F</code> to get reports
of errors and warnings resulting from the use of out-of-date or
non-existent classes, at the expense of increasing compilation time.
By default, Jikes assumes that class files placed in Zip and Jar
files do not reference files not contained in Zip or Jar files; the
<code>+U</code> option should be used when this is not the case.

<h3><a name="incremental"><b>
What is incremental compilation?
</b></a></h3>

<p>Most Java compilers support at least some form of dependency
resolution, where we say that file <code>A</code> <em>depends</em> on
file <code>B</code> if a change to <code>B</code> implies that
<code>A</code> must be rebuilt.  For example, <code>A.class</code>
depends on the source file defining <code>A</code>, usually
<code>A.java</code>.  The <em>make</em> program is commonly used to
record the dependencies and keep files up to date.  <p>Many Java
compilers support a simple make-like function, as follows: when
compiling <code>A</code> check all classes referred to by
<code>A</code> and recompile any whose class file is older than the
source file. This approach can cause problems if this implies
recompiling <code>B</code>, and B is up to date, but uses
<code>C</code> which is out of date, in which case <code>C</code> may
not be recompiled.

<p> Jikes supports the option <code>-depend</code> and interprets it
as a request to recompile all used classes whether or not they are up
to date with respect to their source file.  <p>Jikes also supports
the option <code>+F</code> to force a fuller check of dependency. If
compilation of <code>A.java</code> requires <code>B.class</code> then
<code>B</code> will be recompiled if it is out of date. Once
<code>B.class</code> is available, it is read, and any classes it
references are also checked for dependencies. This fuller check is
more expensive, but will not cause the problems that can result using
the simple approach used by many compilers.

<p>Jikes can also be run in an <em>incremental</em> mode that works
as follows:
<ul>
<li> Open a window and compile your program using
<pre>
    jikes ++ Main.java
</pre>
where <code>Main.java</code> denotes your root source file. Jikes
will then compile <code>Main.java</code> and all the files it
references, building a complete set of dependencies, and will then
wait for input. (Note that <code>++</code> implies <code>+F</code> also.)</li>

<li>Modify your source files using your favorite editor until you
are ready to rebuild your program, and then type an empty line
in the window in which Jikes is waiting. Jikes will then determine
which source files have been changed, and will then perform the minimum
number of compilations needed to bring to class files into a complete
and consistent state. You can repeat this cycle as you wish, until you</li>

<li>Terminate the compilation by typing a single line 
<pre>
    q
</pre>
in the window in which Jikes is waiting. Jikes will then terminate.
</ul>

<p>By the way, you may notice a substantial delay after you type
<code>q</code> to end the incremental mode. This results from the
time needed to execute the destructors invoked to delete all the
nodes in the abstract syntax tree, all the symbols in the symbol
table, etc.  This cost is also incurred whenever the compiler must
delete its current in-memory data structures before compiling a
changed file. We are aware of this cost and are looking at ways to
reduce it, but are making the compiler available with this known
performance limitation so you can try it and test it for correctness.

<h3><a name="make"><b>How do I use Jikes to generate dependencies for make?
</b></a></h3>

<p>Most <code>C</code> and <code>C++</code> compilers support the
option <code>-M</code> to generate dependency information for use
with make. Jikes provides the same function for Java using the option
<code>+M</code>, which requests that Jikes create a file
<code>X.u</code> for each file <code>X.class</code> that is compiled,
and include in this file a list of all the files that
<code>X.class</code> depends on. Note that use of the <code>+M</code>
option turns on full dependency checking (as is done by the
<code>+F</code> option).

<p>The contents of any zip files in <code>CLASSPATH</code> are
assumed to be fixed, and so are not included in the generated
makefiles, mainly to avoid cluttering up the dependency list with
voluminous dependencies on the contents of <code>java.*</code>.

<p>You can also use the option <code>+DR=filename</code> to request
that a dependence report be written to the file
<code>filename</code>. The format is designed to allow the use of the
information as input to a tool; for example, it could be used for a
tool that determines the minimum set of class files that must be
included in a <code>jar</code> file.

<h3><a name="compatible"><b>
Why does Jikes reject a program that another compiler accepts, or accept one that it rejects?
</b></a></h3>
<p>
You may find that Jikes accepts a program that another compiler
rejects (or can't compile), or rejects programs that another compiler
accepts. 

<p>
Each version of Jikes represents our best effort at the proper
interpretation of the language specification. Although Jikes is
designed to work with all but the earliest versions of the JDK, we
make no claim that any particular version supports precisely the same
language as any particular version of the JDK.  Since some products
are designed to work with specific versions of the JDK, the compilers
associated with them may not always recognize the same programs as
Jikes.

<p>
This section contains some examples of issues related to interpreting
the specification.

<h4>Extraneous Semicolons</h4>
<p>Your program may
contain extraneous semicolons that are silently ignored by many compilers.
For example, given
<pre>
   public class Test {
      void f() {};          // first extra semicolon
   };                       // second extra semicolon
</pre>
Jikes accepts the program but issues:
<pre>
     2.       void f() {};       // first extra semicolon
*** Warning: An EmptyDeclaration is a deprecated feature that 
             should not be used - ";" ignored

     3.    };                   // second extra semicolon
            ^
*** Warning: An EmptyDeclaration is a deprecated feature that
             should not be used - ";" ignored
</pre>
The first extra semicolon is erroneous, the second is allowed by section 7.6.
Jikes treats each as cause to issue a warning. You can use the <code>-nowarn</code>
option to suppress this (and other) warnings, or, even better, you can use
your editor to delete those extra semicolons.
<h4>Unreachable Statements</h4>
<p>It is a compile-time error if a statement cannot be executed because
it is <em>unreachable</em> (section 14.19).
When Jikes first appeared, some other compilers didn't properly detect unreachable statements,
and accepted programs such as the following:
<pre>
   class Test {
      void method(boolean b) {
         if (b) return;
         else return;
         b = !b;
      }
   }
</pre>
Jikes rejected this program:
<pre>
            b = !b;
            <----->
    *** Semantic Error: This statement is unreachable
</pre>
(This is the example referrred to in 
<a href="http://www.pcweek.com/news/0414/14ante.html">
PC Week (April 14, 1997):  IBM, Netscape Up Web Ante</a>)
<p>
Another example, and one that confused many users, is shown by
the following program:
<pre>
   class Test {
      public static void main(String[] args){
         try {
         }
         catch (Exception e) {
            System.out.println("caught"); 
         }
      }
   }
</pre>
Jikes accepts this program but issues the warning:
<pre>
          catch (Exception e) {
                 <--------->
  *** Caution: This catch block is unreachable: there is 
      no exception whose type is assignable to 
      "java/lang/Exception" that can be thrown during
      execution of the body of the try block

</pre>
<p>This was the most frequently reported problem when Jikes first appeared.
 It took several months
to confirm that Jikes was right all along. See 
<a href="http://domino.watson.ibm.com/syssftpr/JavaTech/Jikes.nsf/Named/SunQuery2">
Query #2 to Sun
</a> for the full story.

<h4>Cyclic scoping.</h4>
<p>Jikes rejects the program:
<pre>
  class X extends Y.Z {}
  class Y extends X.Z {}
</pre>
because Jikes checks for cycles by grouping types as follows:
<ul>
<li>Types that are package members form a group.</li>
<li>Within the body of a given type, all the inner types immediately
    declared in it form a group. In other words, if we look at the
    complete name of a type beginning with the name of its outermost
    enclosing type, all types that share the same prefix form a group</li>
</ul>
When a type T "extends" or "implements" a type U, we find the
innermost enclosing group that contains an enclosing type Tx of
T (which may be T itself) and an enclosing type Ux of U
(which may be U itself) and add a dependence edge from Tx to Ux.
We then check for cycles in the graph induced by this relationship.
<p>
Consider the following example:

<pre>
class Z {}

class W extends Z
{
    class A
    {
        class x extends B {}
        class y extends x {}
    }

    class B
    {
        class x extends A.x {}
    }

    class C extends B.x {}
}
</pre>

Its dependence graph contains the following edges:
<p>
<ul>
<li> <code>W->Z</code>, since <code>W</code> and <code>Z</code> are both package members</li>
<li> <code>W.A->W.B</code>, because type 
<code>W.A.x</code> extends <code>W.B</code></li> 
<li> <code>W.A.y->W.A.x</code>, because type 
<code>W.A.y</code> extends <code>W.A.x</code></li> 
<li> <code>W.B->W.A</code>, because type 
<code>W.B.x</code> extends <code>W.A.x</code></li> 
<li> <code>W.C->W.B</code>, because type 
<code>W.C</code> extends <code>W.B.x</code></li> 
</ul>

<p>
This graph has a cycle: <code>W.A->W.B->W.A</code>. So Jikes rejects
this program:
<pre>
Found 3 semantic errors compiling "Z.java":

     5.     class A
                      ^
*** Semantic Error: The class "W$A" is circularly defined with
    its super type(s)
  
    ...
</pre>

<p>Another example of cyclic dependence is found in the following code scheme used in some forms
of the Swing package:
<pre>
    class C implements C.I {
        ...
        interface I { ... }
    }
</pre>

<p> This example is cyclic by Jikes's model of dependence. We asked Sun 
about this usage: 
<a href="http://domino.watson.ibm.com/syssftpr/JavaTech/Jikes.nsf/Named/SunQuery31">
Query #31 to Sun: Rules of inheritance of class members</a>.
Their response agrees with our interpretation that this usage is erroneous.

<h4>Queries to Sun</h4>
<p>Here are some more examples of issues related to interpreting the language specification:
<br>
<a href="http://domino.watson.ibm.com/syssftpr/JavaTech/Jikes.nsf/Named/SunQuery1">
Query #1 to Sun: Inner Static 
</a>
<br>
<a href="http://domino.watson.ibm.com/syssftpr/JavaTech/Jikes.nsf/Named/SunQuery2">
Query #2 to Sun: Unreachable Statements
</a>
<br>
<a href="http://domino.watson.ibm.com/syssftpr/JavaTech/Jikes.nsf/Named/SunQuery3">
Query #3 to Sun: Dependence 
</a>
<br>
<a href="http://domino.watson.ibm.com/syssftpr/JavaTech/Jikes.nsf/Named/SunQuery4">
Query #4 to Sun: Are block-level inner interface declarations allowed?
</a>
<br>
<a href="http://domino.watson.ibm.com/syssftpr/JavaTech/Jikes.nsf/Named/SunQuery5">
Query #5 to Sun: String Concatenation Operator + and void 
</a>
<br>
<a href="http://domino.watson.ibm.com/syssftpr/JavaTech/Jikes.nsf/Named/SunQuery6">
Query #6 to Sun: Getting a line on the LineNumberTable
</a>
<br>
<a href="http://domino.watson.ibm.com/syssftpr/JavaTech/Jikes.nsf/Named/SunQuery7">
Query #7 to Sun: Setting of InnerClasses_attribute inner_class_access_flags
</a>
<br>
<a href="http://domino.watson.ibm.com/syssftpr/JavaTech/Jikes.nsf/Named/SunQuery8">
Query #8 to Sun: Scope of Local Variable Declarations and Local Classes
</a>
<br>
<a href="http://domino.watson.ibm.com/syssftpr/JavaTech/Jikes.nsf/Named/SunQuery9">
Query #9 to Sun: Qualifying new for static inner class 
</a>
<br>
<a href="http://domino.watson.ibm.com/syssftpr/JavaTech/Jikes.nsf/Named/SunQuery10">
Query #10 to Sun: Can a class access its own private methods via a subclass? 
</a>
<br>
<a href="http://domino.watson.ibm.com/syssftpr/JavaTech/Jikes.nsf/Named/SunQuery11">
Query #11 to Sun: Access to members in anonymous classes
</a>
<br>
<a href="http://domino.watson.ibm.com/syssftpr/JavaTech/Jikes.nsf/Named/SunQuery12">
Query #12 to Sun: Anonymous inner classes should be final for instanceof and casts
</a>
<br>
<a href="http://domino.watson.ibm.com/syssftpr/JavaTech/Jikes.nsf/Named/SunQuery13">
Query #13 to Sun: Access to inner classes
</a>
<br>
<a href="http://domino.watson.ibm.com/syssftpr/JavaTech/Jikes.nsf/Named/SunQuery14">
Query #14 to Sun: Unreachability and do-while
</a>
<br>
<a href="http://domino.watson.ibm.com/syssftpr/JavaTech/Jikes.nsf/Named/SunQuery15">
Query #15 to Sun: Access control bug with protected member of sibling/outer classes
</a>
<br>
<a href="http://domino.watson.ibm.com/syssftpr/JavaTech/Jikes.nsf/Named/SunQuery16">
Query #16 to Sun: Floating point and bitwise operators
</a>
<br>
<a href="http://domino.watson.ibm.com/syssftpr/JavaTech/Jikes.nsf/Named/SunQuery17">
Query #17 to Sun: Compile-time evaluation of constant expressions
</a>
<br>
<a href="http://domino.watson.ibm.com/syssftpr/JavaTech/Jikes.nsf/Named/SunQuery18">
Query #18 to Sun: Explicit versus implicit setting of attributes, servialVersionUID algorithm
</a>
<br>
<a href="http://domino.watson.ibm.com/syssftpr/JavaTech/Jikes.nsf/Named/SunQuery19">
Query #19 to Sun: Octal escapes in string literals
</a>
<br>
<a href="http://domino.watson.ibm.com/syssftpr/JavaTech/Jikes.nsf/Named/SunQuery20">
Query #20 to Sun: What does "package-private method" mean?
</a>
<br>
<a href="http://domino.watson.ibm.com/syssftpr/JavaTech/Jikes.nsf/Named/SunQuery21">
Query #21 to Sun: Name resolution
</a>
<br>
<a href="http://domino.watson.ibm.com/syssftpr/JavaTech/Jikes.nsf/Named/SunQuery22">
Query #22 to Sun: Circularity problem?
</a>
<br>
<a href="http://domino.watson.ibm.com/syssftpr/JavaTech/Jikes.nsf/Named/SunQuery23">
Query #23 to Sun: Packages and non-existing directories
</a>
<br>
<a href="http://domino.watson.ibm.com/syssftpr/JavaTech/Jikes.nsf/Named/SunQuery24">
Query #24 to Sun: Protected
</a>
<br>
<a href="http://domino.watson.ibm.com/syssftpr/JavaTech/Jikes.nsf/Named/SunQuery25">
Query #25 to Sun: Can user-deifned package have a type named "java"?
</a>
<br>
<a href="http://domino.watson.ibm.com/syssftpr/JavaTech/Jikes.nsf/Named/SunQuery26">
Query #26 to Sun: Acceptability of unreachable byte code
</a>
<br>
<a href="http://domino.watson.ibm.com/syssftpr/JavaTech/Jikes.nsf/Named/SunQuery27">
Query #27 to Sun: Representation of null value
</a>
<br>
<a href="http://domino.watson.ibm.com/syssftpr/JavaTech/Jikes.nsf/Named/SunQuery28">
Query #28 to Sun: Use of anonymous class in explicit constructor invocation
</a>
<br>
<a href="http://domino.watson.ibm.com/syssftpr/JavaTech/Jikes.nsf/Named/SunQuery29">
Query #29 to Sun: When can the ConstantValue attribute be used?
</a>
<br>
<a href="http://domino.watson.ibm.com/syssftpr/JavaTech/Jikes.nsf/Named/SunQuery30">
Query #30 to Sun: Labeled statements and nested classes
</a>
<br>
<a href="http://domino.watson.ibm.com/syssftpr/JavaTech/Jikes.nsf/Named/SunQuery31">
Query #31 to Sun: Rules of inheritance of class members
</a>
<br>
<a href="http://domino.watson.ibm.com/syssftpr/JavaTech/Jikes.nsf/Named/SunQuery32">
Query #32 to Sun: Verification problem
</a>
<br>
<a href="http://domino.watson.ibm.com/syssftpr/JavaTech/Jikes.nsf/Named/SunQuery33">
Query #33 to Sun: Field resolution for interfaces
</a>

<h4>The Unofficial Java Spec Report</h4>
</b></a></h3>
<p><a href="http://www.dina.kvl.dk/~jsr">
The Unofficial Java Spec Report</a>

is an unofficial site that covers problems with the Java Language
Specification, the Java Virtual Machine Specification, and the core API
documents. It is maintained by Roly Perera and Peter Bertelsen, and we 
wish to thank them for their service to the Java community.

<p>Starting with Jikes v0.28, we will attempt to track the recommendations
of the unofficial report, and implement them where feasible. The
current status for the 1.1 portion in Issue 9 (22 May 1998) is as follows:<p>
<ul>
<li>No definition of cyclic scoping -- Jikes has its defintion, as described earlier.    
<li>Resolution of ambiguous names.  Implemented.
<li>
    Access to protected members across nest siblings.  Implemented.
<li>
Can nested interfaces redundantly be declared static? -- Yes.
<li>
    Behavior of <code>new</code> when qualified with an expression that evalutes to
 <code>null</code> is undefined -- Implemented.
<li>
 Rule for making inacessible classes implicitly final is too lax -- 
    Jikes does not make this transformation.
<li>
Reachability of instance initializers and constructors undefined -- Implemented.
<li>
    Initialization requirements for blank final fields incorrect -- Implemented.
<li>
When qualified <code>new</code> or <code>super</code> can be used unspecified --
    Implemented.
<li>
Blank finals and interface fields -- Implemented.
<li>When may <code>this</code> be used in an explicit constructor invocation -- Implemented.
<li>
New hiding rules for parameters and local variables -- implemented.
<li>Blank finals and <code>try</code> statements -- implemented.
<li>
Blank finals and loops -- implemented.
<li>
Unclear whether forward referencing rule changes -- implemented.
<li>Transformations for anonymous classes unspecified -- implemented.
<li>Private methods implicitly final -- implemented.
</ul>
<h3><a name="results"><b>What can I do if I don't get the same
results when using class files generated by Jikes?</b></a></h3>

<p>It is possible that your current compiler was miscompiling the
program and Jikes got it right.  Jikes may have miscompiled your
program and we would appreciate your reporting the problem.  Here are
some steps that may clarify the situation. 

<p>When you run your program using the Java virtual machine, run
<code>java</code> with the option <code>-verify</code> to enable
bytecode verification. If verification this shows one or more class
files are faulty, you've found a bug in Jikes.  Please tell us about
it. 

<p>You should also to see if the Java virtual machine is using a JIT,
in which case you should try with the JIT disabled. We have seen
cases when JIT's fail with class files produced by Jikes, even though
these class files pass verification.  <p>Otherwise build two sets of
class files, one using your current compiler and one using Jikes.
Then, selectively substitute those produced by Jikes until you find a
class file generated by Jikes whose use results in other than the
expected output. If it appears that Jikes is at fault, please tell us
about it. 

<h3><a name="bugs"><b>How do I report bugs?</b></a></h3>

<p>Go to the 
<a href="http://oss.software.ibm.com/developerworks/opensource/jikes/bugs/">
Jikes bug page</a> to report bugs.

<p>
You should provide a small program that reproduces the problem.
If you do can not provide a test case, it in unlikely your
bug will get fixed.

<h3><a name="whyis"><b>Why did IBM Research make the source available?</b></a></h3>

<p>We do many things here at IBM Research, the most important of
which is -- you guessed it -- research.

<p>Work on what is now known as Jikes began in January 1996 when one
of us (Philippe) decided to study the problem of compiling Java. The
other (Dave) joined the project in April 1996, and started out by
writing the bytecode generator. We have worked full-time on the
compiler ever since.

<p>We released Jikes in binary form in April 1997. During the spring
of 1998 we received many requests for a Linux version.  Jikes for
Linux was released on 15 July 1998 -- the response was overwhelming.
Jikes had more downloads in the three months after the announcement
than in the fifteen months before the announcement.  The increase in
downloads was not just for the Linux version: there was a
corresponding surge for the Win95/NT version. We also got many bug
reports -- our main goal in putting out this version.

<p>We knew that putting out a version for Linux would inevitably
raise the question, "Where's the source?"  We received many notes and
comments from users suggesting why this would be a good idea, and
prepared a <a href=
"http://domino.watson.ibm.com/syssftpr/JavaTech/Jikes.nsf/Named/JikesOpenSourceUserCommentsSummary">
Summary of User Comments</a>.  We found their comments persuasive,
and began several months of work that resulted in the release of the
source for Jikes in December 1998. This marked the start of one of
IBM's first efforts in the open-source arena.
<p>
The source was released in part to make a very visible demonstration
of IBM's commitment to open standards and to Java, to make Jikes more
reliable and accessible, to encourage more widespread use of Java, to
encourage standardization of Java, and to gain some experience
actually running an open-source project.


<h3><a name="whatcanido"><b>What can I do with the source?</b></a></h3>

<p>Don't forget to read the license carefully. It explains in detail what you can and cannot do.

<p>You can pretty much do whatever you want -- as long as we get some
acknowledgment.  You can distribute it in binary or source form, take
all or part of it and put it in something else, and then redistribute
it.  It's all up to you.

<p>However, IBM retains control of the names "IBM" and "Jikes<sup><small>TM</small></sup>". You
can't use them without our permission.

<p>You are under no obligation to tell us what you are doing with the
source, or to inform us of any changes you make.

<h3><a name="build"><b>How do I compile the source?</b></a></h3>

<p>
<pre>
    ./configure
    make
</pre>
<p>That should work, if it does not you may need to edit the soure code
or the autoconf/automake build scripts. Gnu make is required to build jikes.

<p>If you want to edit the Java parser rules in java.g, you will also
need to <a
href="http://oss.software.ibm.com/developerworks/opensource/jikes/project/stable">
download the Jikes Parser Generator</a> in its source form, compile it, install it.

<p>We rarely need to run the parser generator.  The published Java
grammar is well-crafted; indeed, we don't recall having to make any
changes to make it acceptable as input to the parser generator. The
rare changes to <code>java.g</code> are those needed to effect a
change in the action code. 

<h3><a name="test"><b>How do I test the compiler?</b></a></h3>

<p>Jikes is now using a new regression testing framework called
Jacks. You will need to check this framework out of the CVS,
use the same CVSROOT you used for jikes, the module name is jacks.
<P>

We are currently working on porting the old regression test suite
over to the new Jacks framework. If you would like to help with
this effort, please join the jikes-dev mailing list.

</body>
</html>
