// $Id: definite.cpp,v 1.44 2002/07/10 04:20:35 cabbey Exp $
//
// This software is subject to the terms of the IBM Jikes Compiler
// License Agreement available at the following URL:
// http://ibm.com/developerworks/opensource/jikes.
// Copyright (C) 1996, 1998, 1999, 2000, 2001, 2002 International Business
// Machines Corporation and others.  All Rights Reserved.
// You must accept the terms of that agreement to use this software.
//
#include "platform.h"
#include "semantic.h"

#ifdef HAVE_JIKES_NAMESPACE
namespace Jikes { // Open namespace Jikes block
#endif

//
// NOTE: This file is used to determine definite assignment and definite
// unassignment rules, per JLS chapter 16.  Often, these are abbreviated
// da and du.  The BitSet type holds a status bit for every variable in
// scope.  Since many rules operate identically on da and du, the DefinitePair
// type is a wrapper for two BitSets.  Finally, boolean expressions can
// cause different definite assignment status during speculation, so
// the DefiniteAssignmentSet is a wrapper for two DefinitePair objects.
//
// It is a compile-time error if a local variable is accessed that is not
// da, and a compile-time error if a blank final is assigned when it is
// not du.  This code also handles the compile-time error when an assignment
// is attempted to an initialized final.
//
// There are two contexts: expression and statement.  In expression context,
// we must pass in the current assignment state and return the resultant
// state (if different) - this is to allow speculative decisions when
// evaluating loop bodies.  In statement context, rather than pass the
// information around, we store it in the instance variable
// *DefinitelyAssignedVariables() for efficiency.
//

inline DefinitePair::DefinitePair(const DefiniteAssignmentSet &set)
    : da_set(set.DASet()),
      du_set(set.DUSet())
{}

inline DefinitePair& DefinitePair::operator=(const DefiniteAssignmentSet& rhs)
{
    da_set = rhs.DASet();
    du_set = rhs.DUSet();
    return *this;
}


//
// There are two versions of DefiniteExpression.  Call this version if the
// expression can be boolean, but there is no need to track the when true
// and when false cases separately; or if the expression cannot be boolean.
// If the expression can be (or always is) boolean, and the when true and
// when false cases matter, call DefiniteBooleanExpression.
//
void Semantic::DefiniteExpression(AstExpression *expr, DefinitePair &def_pair)
{
    if (expr -> IsConstant()) // A constant expression has no effect on DA/DU.
        return;
    DefiniteAssignmentSet *definite = DefiniteBooleanExpression(expr,
                                                                def_pair);
    if (definite)
    {
        def_pair = *definite;
        delete definite;
    }
}

//
// See the comments for DefiniteExpression above.  If the when true and when
// false status differ after this expression, the calling function MUST delete
// the returned object to avoid a memory leak.
//
DefiniteAssignmentSet *Semantic::DefiniteBooleanExpression(AstExpression *expr,
                                                           DefinitePair &def_pair)
{
    DefiniteAssignmentSet *definite = NULL;

    //
    // Is the expression a constant expression of type boolean?
    // Recall that a constant expression does not contain an
    // assignment statement.
    //
    if (IsConstantTrue(expr))
        return new DefiniteAssignmentSet(def_pair, *Universe());
    else if (IsConstantFalse(expr))
        return new DefiniteAssignmentSet(*Universe(), def_pair);
    else if (expr -> symbol != control.no_type)
        definite = (this ->* DefiniteExpr[expr -> kind])(expr, def_pair);

    assert(! definite || expr -> Type() == control.boolean_type);
    return definite;
}


DefiniteAssignmentSet *Semantic::DefiniteSimpleName(AstExpression *expression,
                                                    DefinitePair &def_pair)
{
    AstSimpleName *simple_name = (AstSimpleName *) expression;

    if (simple_name -> resolution_opt)
        return DefiniteBooleanExpression(simple_name -> resolution_opt,
                                         def_pair);

    //
    // Some simple names are undefined. e.g., the simple name in a method call.
    // Others were generated by the compiler as method shadows, so we know
    // when and where they will be properly initialized.
    //
    VariableSymbol *variable = (simple_name -> symbol
                                ? simple_name -> symbol -> VariableCast()
                                : (VariableSymbol *) NULL);
    if (variable && ! variable -> IsSynthetic() &&
        (variable -> IsLocal(ThisMethod()) || variable -> IsFinal(ThisType())))
    {
        int index = variable -> LocalVariableIndex(this);
        //
        // Compile time constants are always da; this matters in switch
        // blocks, where we might have bypassed the initializer.
        //
        if (! def_pair.da_set[index] && ! simple_name -> IsConstant())
        {
            ReportSemError(SemanticError::VARIABLE_NOT_DEFINITELY_ASSIGNED,
                           simple_name -> identifier_token,
                           simple_name -> identifier_token,
                           variable -> Name());

            if (variable -> IsLocal(ThisMethod())) // avoid cascading errors!
                def_pair.da_set.AddElement(index);
        }
    }

    return (DefiniteAssignmentSet *) NULL;
}


DefiniteAssignmentSet *Semantic::DefiniteArrayAccess(AstExpression *expression,
                                                     DefinitePair &def_pair)
{
    AstArrayAccess *array_access = (AstArrayAccess *) expression;

    DefiniteExpression(array_access -> base, def_pair);
    DefiniteExpression(array_access -> expression, def_pair);

    return (DefiniteAssignmentSet *) NULL;
}


DefiniteAssignmentSet *Semantic::DefiniteMethodInvocation(AstExpression *expression,
                                                          DefinitePair &def_pair)
{
    AstMethodInvocation *method_call = (AstMethodInvocation *) expression;

    DefiniteExpression(method_call -> method, def_pair);

    for (int i = 0; i < method_call -> NumArguments(); i++)
    {
        AstExpression *expr = method_call -> Argument(i);
        DefiniteExpression(expr, def_pair);
    }

    return (DefiniteAssignmentSet *) NULL;
}


DefiniteAssignmentSet *Semantic::DefiniteClassInstanceCreationExpression(AstExpression *expression,
                                                                         DefinitePair &def_pair)
{
    AstClassInstanceCreationExpression *class_creation =
        (AstClassInstanceCreationExpression *) expression;
    if (class_creation -> resolution_opt)
        class_creation = class_creation -> resolution_opt;

    if (class_creation -> base_opt)
        DefiniteExpression(class_creation -> base_opt, def_pair);
    for (int k = 0; k < class_creation -> NumArguments(); k++)
    {
        AstExpression *expr = class_creation -> Argument(k);
        DefiniteExpression(expr, def_pair);
    }
    for (int i = 0; i < class_creation -> NumLocalArguments(); i++)
    {
        AstExpression *expr = class_creation -> LocalArgument(i);
        DefiniteExpression(expr, def_pair);
    }

    return (DefiniteAssignmentSet *) NULL;
}


DefiniteAssignmentSet *Semantic::DefiniteArrayCreationExpression(AstExpression *expression,
                                                                 DefinitePair &def_pair)
{
    AstArrayCreationExpression *array_creation =
        (AstArrayCreationExpression *) expression;

    for (int i = 0; i < array_creation -> NumDimExprs(); i++)
    {
        AstDimExpr *dim_expr = array_creation -> DimExpr(i);
        DefiniteExpression(dim_expr -> expression, def_pair);
    }

    if (array_creation -> array_initializer_opt)
        DefiniteArrayInitializer(array_creation -> array_initializer_opt,
                                 def_pair);

    return (DefiniteAssignmentSet *) NULL;
}


inline VariableSymbol *Semantic::DefiniteFinal(AstFieldAccess *field_access)
{
    if (field_access -> resolution_opt)
        field_access = field_access -> resolution_opt -> FieldAccessCast();

    if (field_access)
    {
        VariableSymbol *variable = (field_access -> symbol
                                    ? field_access -> symbol -> VariableCast()
                                    : (VariableSymbol *) NULL);
        if (variable && variable -> IsFinal(ThisType()))
        {
            // There is exactly one copy of a static variable, so, it's
            // always the right one.
            if (variable -> ACC_STATIC())
                return variable;

            AstFieldAccess *sub_field_access =
                field_access -> base -> FieldAccessCast();
            if (field_access -> base -> ThisExpressionCast() ||
                (sub_field_access && sub_field_access -> IsThisAccess()))
            {
                return variable;
            }
        }
    }

    return NULL;
}


DefiniteAssignmentSet *Semantic::DefinitePLUSPLUSOrMINUSMINUS(AstExpression *expr,
                                                              DefinitePair &def_pair)
{
    DefiniteExpression(expr, def_pair);

    //
    // JLS2 added ability for parenthesized variable to remain a variable
    //
    while (expr -> ParenthesizedExpressionCast())
        expr = ((AstParenthesizedExpression *) expr) -> expression;

    VariableSymbol *variable = NULL;
    if (! expr -> ArrayAccessCast()) // some kind of name
    {
        MethodSymbol *read_method = NULL;
        AstSimpleName *simple_name = expr -> SimpleNameCast();
        if (simple_name)
        {
            if (simple_name -> resolution_opt)
               read_method =
                   simple_name -> resolution_opt -> symbol -> MethodCast();
        }
        else
        {
            AstFieldAccess *field_access = expr -> FieldAccessCast();

            assert(field_access);

            if (field_access -> resolution_opt)
                read_method =
                    field_access -> resolution_opt -> symbol -> MethodCast();
        }

        variable = (read_method
                    ? (VariableSymbol *) read_method -> accessed_member
                    : expr -> symbol -> VariableCast());
        while (variable && variable -> accessed_local)
            variable = variable -> accessed_local;
    }

    //
    // If we have a variable and it is final then...
    //
    if (variable && variable -> ACC_FINAL())
    {
        if ((variable -> IsLocal(ThisMethod()) ||
             variable -> IsFinal(ThisType())) &&
            ! variable -> IsSynthetic() &&
            (*BlankFinals())[variable -> LocalVariableIndex(this)])
        {
            ReportSemError(SemanticError::VARIABLE_NOT_DEFINITELY_UNASSIGNED,
                           expr -> LeftToken(),
                           expr -> RightToken(),
                           variable -> Name());
        }
        else
        {
            ReportSemError(SemanticError::FINAL_VARIABLE_NOT_BLANK,
                           expr -> LeftToken(),
                           expr -> RightToken(),
                           variable -> Name());
        }

        // Mark it assigned, to catch further errors.
        if (variable -> IsFinal(ThisType()) && ! variable -> IsSynthetic())
            def_pair.du_set.RemoveElement(variable -> LocalVariableIndex(this));
    }

    return (DefiniteAssignmentSet *) NULL;
}


DefiniteAssignmentSet *Semantic::DefinitePostUnaryExpression(AstExpression *expression,
                                                             DefinitePair &def_pair)
{
    AstPostUnaryExpression *postfix_expression =
        (AstPostUnaryExpression *) expression;
    return DefinitePLUSPLUSOrMINUSMINUS(postfix_expression -> expression,
                                        def_pair);
}


DefiniteAssignmentSet *Semantic::DefiniteNOT(AstExpression *expr,
                                             DefinitePair &def_pair)
{
    DefiniteAssignmentSet *after_expr = DefiniteBooleanExpression(expr,
                                                                  def_pair);
    if (after_expr) // is the expression is a complex boolean expression?
    {
        DefinitePair temp(after_expr -> true_pair);
        after_expr -> true_pair = after_expr -> false_pair;
        after_expr -> false_pair = temp;
    }

    return after_expr;
}


//
// The default pre unary operators are +, -, and ~.
// As these operators are not applicable to boolean expressions,
// we do not need to invoke DefiniteExpression to process them.
//
DefiniteAssignmentSet *Semantic::DefiniteDefaultPreUnaryExpression(AstExpression *expr,
                                                                   DefinitePair &def_pair)
{
    return (this ->* DefiniteExpr[expr -> kind])(expr, def_pair);
}


DefiniteAssignmentSet *Semantic::DefinitePreUnaryExpression(AstExpression *expression,
                                                            DefinitePair &def_pair)
{
    AstPreUnaryExpression *prefix_expression =
        (AstPreUnaryExpression *) expression;
    return (this ->* DefinitePreUnaryExpr[prefix_expression -> pre_unary_tag])
        (prefix_expression -> expression, def_pair);
}


DefiniteAssignmentSet *Semantic::DefiniteAND_AND(AstBinaryExpression *expr,
                                                 DefinitePair &def_pair)
{
    DefiniteAssignmentSet *after_left =
        DefiniteBooleanExpression(expr -> left_expression, def_pair);
    DefinitePair *before_right = NULL;
    if (after_left)
        def_pair = after_left -> true_pair;
    else
        before_right = new DefinitePair(def_pair);

    DefiniteAssignmentSet *after_right =
        DefiniteBooleanExpression(expr -> right_expression, def_pair);

    if (after_left)
    {
        if (after_right)
        {
            after_right -> false_pair *= after_left -> false_pair;
            delete after_left;
        }
        else
        {
            after_right = after_left;
            after_right -> true_pair = def_pair;
            after_right -> false_pair *= def_pair;
        }
    }
    else
    {
        if (! after_right)
            after_right = new DefiniteAssignmentSet(def_pair);

        after_right -> false_pair *= *before_right;
    }

    // harmless if NULL
    delete before_right;

    return after_right;
}


DefiniteAssignmentSet *Semantic::DefiniteOR_OR(AstBinaryExpression *expr,
                                               DefinitePair &def_pair)
{
    DefiniteAssignmentSet *after_left =
        DefiniteBooleanExpression(expr -> left_expression, def_pair);
    DefinitePair *before_right = NULL;
    if (after_left)
        def_pair = after_left -> false_pair;
    else
        before_right = new DefinitePair(def_pair);

    DefiniteAssignmentSet *after_right =
        DefiniteBooleanExpression(expr -> right_expression, def_pair);

    if (after_left)
    {
        if (after_right)
        {
            after_right -> true_pair *= after_left -> true_pair;
            delete after_left;
        }
        else
        {
            after_right = after_left;
            after_right -> true_pair *= def_pair;
            after_right -> false_pair = def_pair;
        }
    }
    else
    {
        if (! after_right)
            after_right = new DefiniteAssignmentSet(def_pair);

        after_right -> true_pair *= *before_right;
    }

    // harmless if NULL
    delete before_right;

    return after_right;
}


DefiniteAssignmentSet *Semantic::DefiniteDefaultBinaryExpression(AstBinaryExpression *expr,
                                                                 DefinitePair &def_pair)
{
    DefiniteExpression(expr -> left_expression, def_pair);
    DefiniteExpression(expr -> right_expression, def_pair);

    return (DefiniteAssignmentSet *) NULL;
}


DefiniteAssignmentSet *Semantic::DefiniteBinaryExpression(AstExpression *expression,
                                                          DefinitePair &def_pair)
{
    AstBinaryExpression *binary_expression =
        (AstBinaryExpression *) expression;
    return (this ->* DefiniteBinaryExpr[binary_expression -> binary_tag])
        (binary_expression, def_pair);
}


DefiniteAssignmentSet *Semantic::DefiniteConditionalExpression(AstExpression *expression,
                                                               DefinitePair &def_pair)
{
    AstConditionalExpression *conditional_expression =
        (AstConditionalExpression *) expression;

    DefiniteAssignmentSet *after_condition =
        DefiniteBooleanExpression(conditional_expression -> test_expression,
                                  def_pair);
    DefinitePair *before_expressions = NULL;

    if (after_condition)
        def_pair = after_condition -> true_pair;
    else before_expressions = new DefinitePair(def_pair);
    DefiniteAssignmentSet *after_true =
        DefiniteBooleanExpression(conditional_expression -> true_expression,
                                  def_pair);
    DefinitePair *after_true_pair = (after_true ? (DefinitePair *) NULL
                                     : new DefinitePair(def_pair));

    if (after_condition)
         def_pair = after_condition -> false_pair;
    else def_pair = *before_expressions;
    DefiniteAssignmentSet *after_false =
        DefiniteBooleanExpression(conditional_expression -> false_expression,
                                  def_pair);

    if (conditional_expression -> Type() == control.boolean_type)
    {
        if (! after_true)
            after_true = new DefiniteAssignmentSet(*after_true_pair);

        if (after_false)
        {
            after_true -> true_pair *= after_false -> true_pair;
            after_true -> false_pair *= after_false -> false_pair;
        }
        else
        {
            after_true -> true_pair *= def_pair;
            after_true -> false_pair *= def_pair;
        }
    }
    else
    {
        assert(! after_true && ! after_false);
        def_pair *= *after_true_pair;
    }

    // harmless if NULL
    delete after_condition;
    delete before_expressions;
    delete after_false;

    return after_true;
}


DefiniteAssignmentSet *Semantic::DefiniteAssignmentExpression(AstExpression *expression,
                                                              DefinitePair &def_pair)
{
    AstAssignmentExpression *assignment_expression =
        (AstAssignmentExpression *) expression;

    AstCastExpression *casted_left_hand_side =
        assignment_expression -> left_hand_side -> CastExpressionCast();
    AstExpression *left_hand_side = (casted_left_hand_side
                                     ? casted_left_hand_side -> expression
                                     : assignment_expression -> left_hand_side);
    bool simple_name = false;
    if (left_hand_side -> SimpleNameCast())
    {
        AstSimpleName *simple = (AstSimpleName *) left_hand_side;
        if (simple -> resolution_opt)
        {
            left_hand_side = simple -> resolution_opt;
            simple_name = (left_hand_side -> SimpleNameCast() != NULL);
        }
        else simple_name = true;
    }
    else
    {
        AstFieldAccess *field_access = left_hand_side -> FieldAccessCast();
        if (field_access)
        {
            if (field_access -> resolution_opt)
                left_hand_side = field_access -> resolution_opt;
            //
            // Because constructor parameters often shadow field names,
            // this.name is legal for final instance fields. However, anything
            // more complex, such as (this).name or Classname.this.name, as
            // well as Classname.name for static fields or expression.name in
            // general, will be rejected.
            // TODO: This is not well-specified in the JLS; rather we are just
            // following the lead of Sun's javac 1.4.1. Clean this code up when
            // a decent specification is given.
            //
            if (field_access -> base -> ThisExpressionCast())
                simple_name = true;
        }
    }

    VariableSymbol *variable = (left_hand_side -> symbol
                                ? left_hand_side -> symbol -> VariableCast()
                                : (VariableSymbol *) NULL);
    while (variable && variable -> accessed_local)
        variable = variable -> accessed_local;
    int index = 0;

    //
    // An array access is never considered to be final. Since no variable
    // is associated with the array access, the testing for the presence of
    // variable takes care of that possibility.
    //
    if (variable)
    {
        if (variable -> IsLocal(ThisMethod()) ||
            variable -> IsFinal(ThisType()))
        {
            index = variable -> LocalVariableIndex(this);

            //
            // If we have a compound assignment then the variable must have
            // been set prior to such an assignment. otherwise, an error
            // occurs.
            //
            if (! assignment_expression -> SimpleAssignment() &&
                ! def_pair.da_set[index])
            {
                ReportSemError(SemanticError::VARIABLE_NOT_DEFINITELY_ASSIGNED,
                               left_hand_side -> LeftToken(),
                               left_hand_side -> RightToken(),
                               variable -> Name());
            }
        }
        else if (variable -> ACC_FINAL())
        {
            // attempt to assign a value to a final field member!
            ReportSemError(SemanticError::FINAL_VARIABLE_NOT_BLANK,
                           left_hand_side -> LeftToken(),
                           left_hand_side -> RightToken(),
                           variable -> Name());
        }
    }

    //
    // The left-hand-side of an assignment expression is either a simple name,
    // a field access or an array access.  A simple name does not need further
    // action, a field access needs to descend into all qualifying expressions,
    // and an array access needs to descend into the entire expression. 
    //
    if (! simple_name)
    {
        AstFieldAccess *field_access = left_hand_side -> FieldAccessCast();
        DefiniteExpression((field_access ? field_access -> base
                            : left_hand_side),
                           def_pair);
    }

    //
    // JLS2 16.1.7 - The rules for definite assignment of boolean valued
    // assignments are stricter than they were in JLS1; hence we no longer
    // consider the when true and when false values separately.
    //
    DefiniteExpression(assignment_expression -> expression, def_pair);

    //
    // Finally, we mark the variable as assigned.
    //
    if (variable &&
        (variable -> IsLocal(ThisMethod()) || variable -> IsFinal(ThisType())))
    {
        if (variable -> ACC_FINAL())
        {
            //
            // It is an error to assign any final except a DU blank final. Also,
            // final fields must be assigned by simple name, or by this.name.
            //
            if (! (*BlankFinals())[index] || ! def_pair.du_set[index])
            {
                ReportSemError(((*BlankFinals())[index]
                                ? SemanticError::VARIABLE_NOT_DEFINITELY_UNASSIGNED
                                : SemanticError::FINAL_VARIABLE_NOT_BLANK),
                               left_hand_side -> LeftToken(),
                               left_hand_side -> RightToken(),
                               variable -> Name());
            }
            else if (variable -> IsFinal(ThisType()) && ! simple_name)
            {
                ReportSemError(SemanticError::FINAL_FIELD_ASSIGNMENT_NOT_SIMPLE,
                               left_hand_side -> LeftToken(),
                               left_hand_side -> RightToken(),
                               variable -> Name(),
                               (variable -> ACC_STATIC() ? NULL
                                : variable -> Name()));
            }
            // are we processing the body of a loop ?
            else if (DefiniteFinalAssignments() -> Size() > 0)
                DefiniteFinalAssignments() -> Top().Next() =
                    left_hand_side;
        }

        def_pair.AssignElement(index);
    }

    return (DefiniteAssignmentSet *) NULL;
}

DefiniteAssignmentSet *Semantic::DefiniteDefaultExpression(AstExpression *expr,
                                                           DefinitePair &def_pair)
{
    return (DefiniteAssignmentSet *) NULL;
}

DefiniteAssignmentSet *Semantic::DefiniteParenthesizedExpression(AstExpression *expression,
                                                                 DefinitePair &def_pair)
{
    AstParenthesizedExpression *expr =
        (AstParenthesizedExpression *) expression;

    return DefiniteBooleanExpression(expr -> expression, def_pair);
}

DefiniteAssignmentSet *Semantic::DefiniteFieldAccess(AstExpression *expression,
                                                     DefinitePair &def_pair)
{
    AstFieldAccess *expr = (AstFieldAccess *) expression;

    //
    // TODO: Sun bug 4395322 mentions that DA is underspecified for field
    // references.  In other words, it is legal to read an uninitialized
    // static value through Classname.fieldname, or an instance value
    // through this.fieldname. If Sun specifies that this behavior is correct,
    // this commented code can be removed.
    //
    //      VariableSymbol *variable = DefiniteFinal(expr);
    //      if (variable)
    //      {
    //          if (! def_pair.da_set[variable -> LocalVariableIndex(this)])
    //          {
    //              ReportSemError(SemanticError::VARIABLE_NOT_DEFINITELY_ASSIGNED,
    //                             expr -> LeftToken(),
    //                             expr -> RightToken(),
    //                             variable -> Name());
    //              // supress further warnings
    //              def_pair.da_set.AddElement(variable -> LocalVariableIndex(this));
    //          }
    //      }

    return DefiniteBooleanExpression((expr -> resolution_opt
                                      ? expr -> resolution_opt
                                      : expr -> base), def_pair);
}

DefiniteAssignmentSet *Semantic::DefiniteCastExpression(AstExpression *expression,
                                                        DefinitePair &def_pair)
{
    AstCastExpression *expr = (AstCastExpression *) expression;

    return DefiniteBooleanExpression(expr -> expression, def_pair);
}


//
// Must have two versions, since this can be called in both expression and
// statement context.
//
void Semantic::DefiniteArrayInitializer(AstArrayInitializer *array_initializer,
                                        DefinitePair &def_pair)
{
    for (int i = 0; i < array_initializer -> NumVariableInitializers(); i++)
    {
        AstArrayInitializer *sub_array_initializer = array_initializer ->
            VariableInitializer(i) -> ArrayInitializerCast();

        if (sub_array_initializer)
            DefiniteArrayInitializer(sub_array_initializer, def_pair);
        else
        {
            AstExpression *init =
                (AstExpression *) array_initializer -> VariableInitializer(i);
            DefiniteExpression(init, def_pair);
        }
    }
}

inline void Semantic::DefiniteArrayInitializer(AstArrayInitializer *array_initializer)
{
    DefiniteArrayInitializer(array_initializer,
                             *DefinitelyAssignedVariables());
}


inline void Semantic::DefiniteVariableInitializer(AstVariableDeclarator *variable_declarator)
{
    assert(variable_declarator -> variable_initializer_opt);
    AstExpression *init =
        variable_declarator -> variable_initializer_opt -> ExpressionCast();
    if (! init)
        DefiniteArrayInitializer((AstArrayInitializer *) variable_declarator ->
                                 variable_initializer_opt,
                                 *DefinitelyAssignedVariables());
    else
        DefiniteExpression(init, *DefinitelyAssignedVariables());

    //
    // Even when initialized by a non-constant, variables declared in a
    // switch are necessarily blank finals.
    // TODO: Sun has never given any nice official word on this.
    //
    if (DefiniteBlocks() &&
        DefiniteBlocks() -> TopBlock() -> block_tag == AstBlock::SWITCH &&
        (! init || ! init -> IsConstant()))
    {
        BlankFinals() -> AddElement(variable_declarator -> symbol ->
                                   LocalVariableIndex(this));
    }
    
}


inline void Semantic::DefiniteStatement(Ast *ast)
{
    (this ->* DefiniteStmt[ast -> kind])(ast);
}

inline void Semantic::DefiniteBlockStatements(AstBlock *block_body)
{
    for (int i = 0; i < block_body -> NumStatements(); i++)
    {
        AstStatement *statement = (AstStatement *) block_body -> Statement(i);
        //
        // As unreachable statements already cause an error, we avoid
        // them here
        //
        if (statement -> is_reachable)
            DefiniteStatement(statement);
        else break;
    }
}


void Semantic::DefiniteBlock(Ast *stmt)
{
    AstBlock *block_body = (AstBlock *) stmt;

    DefiniteBlocks() -> Push(block_body);

    for (int i = 0;
         i < block_body -> block_symbol -> NumVariableSymbols(); i++)
    {
        DefiniteVisibleVariables() -> AddElement(block_body -> block_symbol ->
                                                 VariableSym(i));
    }

    DefiniteBlockStatements(block_body);

#ifdef DUMP
    if ((control.option.g & JikesOption::VARS) &&
        block_body -> NumLocallyDefinedVariables() > 0)
    {
        Coutput << "(3) At Line "
                << lex_stream -> Line(block_body -> RightToken())
                << " the range for the following variables end:" << endl
                << endl;
        for (int j = 0; j < block_body -> NumLocallyDefinedVariables(); j++)
            Coutput << "    \""
                    << block_body -> LocallyDefinedVariable(j) -> Name()
                    << "\"" << endl;
    }
#endif
    //
    // Remove all variables that just went out of scope
    //
    for (int k = 0;
         k < block_body -> block_symbol -> NumVariableSymbols(); k++)
    {
        VariableSymbol *variable =
            block_body -> block_symbol -> VariableSym(k);

        BlankFinals() -> RemoveElement(variable -> LocalVariableIndex(this));
        DefinitelyAssignedVariables() ->
            ReclaimElement(variable -> LocalVariableIndex(this));

        DefiniteVisibleVariables() -> RemoveElement(variable);
    }

    //
    // Note that in constructing the Ast, the parser encloses each
    // labeled statement in its own block... Therefore, only blocks
    // are labeled.
    //
    if (block_body -> label_opt)
        *DefinitelyAssignedVariables() *=
            DefiniteBlocks() -> TopBreakPair();

    DefiniteBlocks() -> Pop();
}


void Semantic::DefiniteLocalVariableDeclarationStatement(Ast *stmt)
{
    AstLocalVariableDeclarationStatement *local_decl =
        (AstLocalVariableDeclarationStatement *) stmt;

    for (int i = 0; i < local_decl -> NumVariableDeclarators(); i++)
    {
        AstVariableDeclarator *variable_declarator =
            local_decl -> VariableDeclarator(i);
        VariableSymbol *variable_symbol = variable_declarator -> symbol;
        if (! variable_symbol)
            continue;
        int index = variable_symbol -> LocalVariableIndex(this);
        if (control.option.g & JikesOption::VARS)
        {
            assert(! DefiniteBlocks() -> TopLocalVariables()[index]);
#ifdef DUMP
            Coutput << "(3.5) Local Variable \"" << variable_symbol -> Name()
                    << " #" << index << "\" is declared at line "
                    << lex_stream -> Line(variable_declarator -> LeftToken())
                    << endl;
#endif
            DefiniteBlocks() -> TopLocalVariables()[index] = variable_symbol;
            DefiniteBlocks() -> TopLocallyDefinedVariables() ->
                AddElement(index);
            AstBlock *block = DefiniteBlocks() -> TopBlock();
            block -> AddLocallyDefinedVariable(variable_symbol);
        }

        if (variable_declarator -> variable_initializer_opt)
        {
            DefiniteVariableInitializer(variable_declarator);
            DefinitelyAssignedVariables() -> AssignElement(index);
        }
        else
        {
            DefinitelyAssignedVariables() -> ReclaimElement(index);
            if (variable_symbol -> ACC_FINAL())
                BlankFinals() -> AddElement(index);
        }
    }
}


void Semantic::DefiniteExpressionStatement(Ast *stmt)
{
    AstExpressionStatement *expression_statement =
        (AstExpressionStatement *) stmt;

    DefiniteExpression(expression_statement -> expression,
                       *DefinitelyAssignedVariables());
}


void Semantic::DefiniteSynchronizedStatement(Ast *stmt)
{
    AstSynchronizedStatement *synchronized_statement =
        (AstSynchronizedStatement *) stmt;

    DefiniteExpression(synchronized_statement -> expression,
                       *DefinitelyAssignedVariables());

    DefiniteBlock(synchronized_statement -> block);
}


void Semantic::DefiniteIfStatement(Ast *stmt)
{
    AstIfStatement *if_statement = (AstIfStatement *) stmt;

    DefiniteAssignmentSet *after_expr =
        DefiniteBooleanExpression(if_statement -> expression,
                                  *DefinitelyAssignedVariables());
    DefinitePair *starting_pair =
        new DefinitePair(*DefinitelyAssignedVariables());
    if (after_expr)
        *DefinitelyAssignedVariables() = after_expr -> true_pair;

    //
    // Recall that the parser ensures that the statements that appear in an
    // if-statement (both the true and false statement) are enclosed in a
    // block.
    //
    DefiniteBlock(if_statement -> true_statement);

    if (! if_statement -> false_statement_opt) // no else part ?
    {
        *DefinitelyAssignedVariables() *= (after_expr
                                           ? after_expr -> false_pair
                                           : *starting_pair);
    }
    else
    {
        DefinitePair true_set(*DefinitelyAssignedVariables());
        *DefinitelyAssignedVariables() = (after_expr
                                          ? after_expr -> false_pair
                                          : *starting_pair);

        DefiniteBlock(if_statement -> false_statement_opt);

        *DefinitelyAssignedVariables() *= true_set;
    }

    // harmless if NULL
    delete starting_pair;
}


void Semantic::DefiniteLoopBody(BitSet *starting_set)
{
    BitSet exit_set(DefinitelyAssignedVariables() -> du_set);
    exit_set *= DefiniteBlocks() -> TopContinuePair().du_set;

    //
    // Find the set of variables that were DU before the loop, but not DU
    // before a continue or at the loop end.
    //
    *starting_set -= exit_set;

    for (int k = 0; k < DefiniteFinalAssignments() -> Top().Length(); k++)
    {
        AstExpression *name = DefiniteFinalAssignments() -> Top()[k];
        VariableSymbol *variable = (VariableSymbol *) name -> symbol;

        if (DefiniteVisibleVariables() -> IsElement(variable) &&
            (*starting_set)[variable -> LocalVariableIndex(this)])
        {
            ReportSemError(((*BlankFinals())[variable -> LocalVariableIndex(this)]
                            ? SemanticError::VARIABLE_NOT_DEFINITELY_UNASSIGNED_IN_LOOP
                            : SemanticError::FINAL_VARIABLE_NOT_BLANK),
                           name -> LeftToken(),
                           name -> RightToken(),
                           variable -> Name());
        }
    }

    DefinitelyAssignedVariables() -> du_set =
        exit_set * DefiniteBlocks() -> TopBreakPair().du_set;
    DefiniteFinalAssignments() -> Pop();
}


void Semantic::DefiniteWhileStatement(Ast *stmt)
{
    AstWhileStatement *while_statement = (AstWhileStatement *) stmt;

    BreakableStatementStack().Push(DefiniteBlocks() -> TopBlock());
    ContinuableStatementStack().Push(stmt);
    DefiniteFinalAssignments() -> Push();

    BitSet *starting_set = new BitSet(DefinitelyAssignedVariables() -> du_set);
    DefiniteAssignmentSet *after_expr =
        DefiniteBooleanExpression(while_statement -> expression,
                                  *DefinitelyAssignedVariables());
    DefinitePair before_statement(Universe() -> Size());

    if (after_expr)
        *DefinitelyAssignedVariables() = after_expr -> true_pair;
    else before_statement = *DefinitelyAssignedVariables();

    //
    // We have already given a warning if the statement is unreachable
    //
    if (while_statement -> statement -> is_reachable)
        DefiniteStatement(while_statement -> statement);
    DefiniteLoopBody(starting_set);
    *DefinitelyAssignedVariables() = DefiniteBlocks() -> TopBreakPair() *
        (after_expr ? after_expr -> false_pair : before_statement);

    delete after_expr;
    delete starting_set;

    ContinuableStatementStack().Pop();
    BreakableStatementStack().Pop();
}


void Semantic::DefiniteForStatement(Ast *stmt)
{
    AstForStatement *for_statement = (AstForStatement *) stmt;

    //
    // Note that in constructing the Ast, the parser encloses each
    // for-statement whose for-init-statements starts with a local
    // variable declaration in its own block. Therefore a redeclaration
    // of another local variable with the same name in a different loop
    // at the same nesting level will not cause any conflict.
    //
    // For example, the following sequence of statements is legal:
    //
    //     for (int i = 0; i < 10; i++);
    //     for (int i = 10; i < 20; i++);
    //
    for (int i = 0; i < for_statement -> NumForInitStatements(); i++)
    {
        DefiniteStatement(for_statement -> ForInitStatement(i));
    }

    BreakableStatementStack().Push(DefiniteBlocks() -> TopBlock());
    ContinuableStatementStack().Push(stmt);
    DefiniteFinalAssignments() -> Push();

    BitSet *starting_set = new BitSet(DefinitelyAssignedVariables() -> du_set);
    DefiniteAssignmentSet *after_end_expression = NULL;
    DefinitePair before_statement(Universe() -> Size());

    if (for_statement -> end_expression_opt)
        after_end_expression =
            DefiniteBooleanExpression(for_statement -> end_expression_opt,
                                      *DefinitelyAssignedVariables());

    if (after_end_expression)
        *DefinitelyAssignedVariables() = after_end_expression -> true_pair;
    else before_statement = *DefinitelyAssignedVariables();

    //
    // We have already given a warning if the statement is unreachable
    //
    if (for_statement -> statement -> is_reachable)
        DefiniteStatement(for_statement -> statement);

    //
    // Compute the set of variables that are definitely assigned after the
    // contained statement and after every continue statement that may exit
    // the body of the for statement.
    //
    if (for_statement -> statement -> can_complete_normally)
    {
        *DefinitelyAssignedVariables() *=
            DefiniteBlocks() -> TopContinuePair();
        for (int j = 0; j < for_statement -> NumForUpdateStatements(); j++)
            DefiniteExpressionStatement(for_statement ->
                                        ForUpdateStatement(j));
        DefiniteLoopBody(starting_set);
    }
    else
    {
        *DefinitelyAssignedVariables() = *Universe();
        for (int j = 0; j < for_statement -> NumForUpdateStatements(); j++)
            DefiniteExpressionStatement(for_statement ->
                                        ForUpdateStatement(j));
    }

    //
    // Compute the set of variables that belongs to both sets below:
    //
    //    . the universe if no condition expression is present;
    //      otherwise, the set of variables that are DA when
    //      the condition expression is false.
    //
    //    . the set of variables that are DA before every
    //      break statement that may exit the for statement.
    //
    *DefinitelyAssignedVariables() = (for_statement -> end_expression_opt
                                      ? (after_end_expression
                                         ? after_end_expression -> false_pair
                                         : before_statement)
                                      : *Universe());

    //
    // The replacement
    //
    *DefinitelyAssignedVariables() *= DefiniteBlocks() -> TopBreakPair();

    delete after_end_expression; // harmless if NULL
    delete starting_set;

    ContinuableStatementStack().Pop();
    BreakableStatementStack().Pop();
}


void Semantic::DefiniteDoStatement(Ast *stmt)
{
    AstDoStatement *do_statement = (AstDoStatement *) stmt;

    BreakableStatementStack().Push(DefiniteBlocks() -> TopBlock());
    ContinuableStatementStack().Push(stmt);
    DefiniteFinalAssignments() -> Push();

    BitSet *starting_set = new BitSet(DefinitelyAssignedVariables() -> du_set);

    DefiniteStatement(do_statement -> statement);

    DefinitePair after_stmt(*DefinitelyAssignedVariables());
    *DefinitelyAssignedVariables() *=
        DefiniteBlocks() -> TopContinuePair();
    DefiniteAssignmentSet *after_expr =
        DefiniteBooleanExpression(do_statement -> expression,
                                  *DefinitelyAssignedVariables());
    DefinitePair after_loop(Universe() -> Size());

    if (after_expr)
        *DefinitelyAssignedVariables() = after_expr -> true_pair;
    else after_loop = *DefinitelyAssignedVariables();
    DefiniteLoopBody(starting_set);

    *DefinitelyAssignedVariables() = DefiniteBlocks() -> TopBreakPair() *
        (after_expr ? after_expr -> false_pair : after_loop);

    delete after_expr;
    delete starting_set;

    ContinuableStatementStack().Pop();
    BreakableStatementStack().Pop();
}


void Semantic::DefiniteSwitchStatement(Ast *stmt)
{
    AstSwitchStatement *switch_statement = (AstSwitchStatement *) stmt;

    AstBlock *block_body = switch_statement -> switch_block;
    DefiniteBlocks() -> Push(block_body);
    BreakableStatementStack().Push(block_body);

    DefiniteExpression(switch_statement -> expression,
                       *DefinitelyAssignedVariables());

    DefinitePair starting_pair(*DefinitelyAssignedVariables());

    //
    // Recall that the parser inserts an empty statement if necessary after
    // the last label, so that all SwitchBlockStatementGroups have statements
    //
    int i;
    for (i = 0; i < block_body -> NumStatements(); i++)
    {
        AstSwitchBlockStatement *switch_block_statement =
            (AstSwitchBlockStatement *) block_body -> Statement(i);

        *DefinitelyAssignedVariables() *= starting_pair;

        for (int j = 0; j < switch_block_statement -> NumStatements(); j++)
        {
            AstStatement *statement =
                (AstStatement *) switch_block_statement -> Statement(j);
            //
            // As unreachable statements already cause an error, we avoid
            // them here
            //
            if (statement -> is_reachable)
                DefiniteStatement(statement);
            else break;
        }
    }

    //
    // TODO: What if the switch enumerates all 256 byte cases without a
    // default label?
    //
    if (switch_statement -> default_case.switch_block_statement)
        *DefinitelyAssignedVariables() *=
            DefiniteBlocks() -> TopBreakPair();
    else *DefinitelyAssignedVariables() = starting_pair;

    //
    // Remove all variables that just went out of scope
    //
    for (i = 0; i < block_body -> block_symbol -> NumVariableSymbols(); i++)
    {
        VariableSymbol *variable =
            block_body -> block_symbol -> VariableSym(i);

        BlankFinals() -> RemoveElement(variable -> LocalVariableIndex(this));
        DefinitelyAssignedVariables() ->
            ReclaimElement(variable -> LocalVariableIndex(this));

        DefiniteVisibleVariables() -> RemoveElement(variable);
    }

    BreakableStatementStack().Pop();
    DefiniteBlocks() -> Pop();
}


void Semantic::DefiniteBreakStatement(Ast *stmt)
{
    AstBreakStatement *break_statement = (AstBreakStatement *) stmt;

    //
    // Compute the set of variables that are definitely assigned prior to
    // executing the break, including if the break occurs in a try or catch
    // block.
    //
    DefiniteBlocks() -> BreakPair(break_statement -> nesting_level) *=
        *DefinitelyAssignedVariables();
    if (DefiniteTrys() -> Size() > 0)
    {
        for (int i = DefiniteTrys() -> Size() - 1; i >= 0; i--)
        {
            AstTryStatement *try_statement =
                DefiniteTrys() -> TryStatement(i);

            if (try_statement -> block == DefiniteTrys() -> Block(i))
            {
                // In the main try block?
                int k;
                for (k = DefiniteBlocks() -> Size() - 1;
                     DefiniteBlocks() -> Block(k) !=
                         DefiniteTrys() -> Block(i);
                     k--)
                    ;

                assert(k >= 0);

                DefiniteBlocks() -> BreakPair(k) *=
                    *DefinitelyAssignedVariables();
                break;
            }
            else if (try_statement -> finally_clause_opt)
            {
                int k;
                for (k = DefiniteBlocks() -> Size() - 1;
                     DefiniteBlocks() -> Block(k) !=
                         DefiniteTrys() -> Block(i);
                     k--)
                    ;

                assert(k >= 0);

                DefiniteBlocks() -> BreakPair(k) *=
                    *DefinitelyAssignedVariables();
                break;
            }
        }
    }

    //
    // After execution of a break statement, it is vacuously true
    // that every variable has definitely been assigned and no final
    // variable has been possibly assigned (as nothing is reachable
    // any way).
    //
    *DefinitelyAssignedVariables() = *Universe();
}


void Semantic::DefiniteContinueStatement(Ast *stmt)
{
    AstContinueStatement *continue_statement = (AstContinueStatement *) stmt;

    //
    // Compute the set of variables that are definitely assigned prior to
    // executing the continue, including if the continue occurs in a try or
    // catch block.
    //
    DefiniteBlocks() -> ContinuePair(continue_statement -> nesting_level) *=
        *DefinitelyAssignedVariables();
    if (DefiniteTrys() -> Size() > 0)
    {
        for (int i = DefiniteTrys() -> Size() - 1; i >= 0; i--)
        {
            AstTryStatement *try_statement =
                DefiniteTrys() -> TryStatement(i);

            if (try_statement -> block == DefiniteTrys() -> Block(i))
            {
                // In the main try block?
                int k;
                for (k = DefiniteBlocks() -> Size() - 1;
                     DefiniteBlocks() -> Block(k) !=
                         DefiniteTrys() -> Block(i);
                     k--)
                    ;

                assert(k >= 0);

                DefiniteBlocks() -> ContinuePair(k) *=
                    *DefinitelyAssignedVariables();
                break;
            }
            else if (try_statement -> finally_clause_opt)
            {
                int k;
                for (k = DefiniteBlocks() -> Size() - 1;
                     DefiniteBlocks() -> Block(k) !=
                         DefiniteTrys() -> Block(i);
                     k--)
                    ;

                assert(k >= 0);

                DefiniteBlocks() -> ContinuePair(k) *=
                    *DefinitelyAssignedVariables();
                break;
            }
        }
    }

    //
    // After execution of a continue statement, it is vacuously true
    // that every variable has definitely been assigned and no final
    // variable has been possibly assigned (as nothing is reachable
    // any way).
    //
    *DefinitelyAssignedVariables() = *Universe();
}


void Semantic::DefiniteReturnStatement(Ast *stmt)
{
    AstReturnStatement *return_statement = (AstReturnStatement *) stmt;

    if (return_statement -> expression_opt)
        DefiniteExpression(return_statement -> expression_opt,
                           *DefinitelyAssignedVariables());

    //
    // Compute the set of variables that are definitely assigned prior to
    // executing this return statement. Note that this set is only relevant
    // to the method or constructor block containing this statement.
    //
    // TODO: Do we really need this?
    //
    //    DefiniteBlocks() -> TopReturnSet() *= (*DefinitelyAssignedVariables());
    //

    //
    // Compute the set of variables that are possibly assigned prior to
    // executing this return statement.
    // We have a few cases to consider:
    //
    //    1. The return statement is not contained in a try statement - the
    //       possibly-assigned set is only relevant to the enclosing method
    //       (or constructor) block. The definitely assigned set is updated
    //       as if the return statement was a break statement out of the
    //       method (or constructor) block.
    //
    //    2. If the return statement is contained in a try main block or a try
    //       catch block that contains a finally clause - the possibly-assigned
    //       block is relevant to that main try block or catch block.
    //
    //    3. otherwise, treat the return statement as if it immediately
    //       followed its containing try statement
    //
    if (DefiniteTrys() -> Size() == 0)
        DefiniteBlocks() -> ReturnPair(0) *= *DefinitelyAssignedVariables();
    else
    {
        for (int i = DefiniteTrys() -> Size() - 1; i >= 0; i--)
        {
            AstTryStatement *try_statement =
                DefiniteTrys() -> TryStatement(i);
            //
            // Is the return statement enclosed in a try main block or catch
            // block that  contains a finally clause. Note that a try
            // statement is removed from the DefiniteTrys() before its
            // finally clause is processed. thus, a return statement that is
            // enclosed in a finally clause will appear in an enclosing
            // try statement, if any...
            //
            if (try_statement -> block == DefiniteTrys() -> Block(i))
            {
                // In the main try block?
                int k;
                for (k = DefiniteBlocks() -> Size() - 1;
                     DefiniteBlocks() -> Block(k) !=
                         DefiniteTrys() -> Block(i);
                     k--);

                assert(k >= 0);

                DefiniteBlocks() -> ReturnPair(k) *=
                    *DefinitelyAssignedVariables();
                break;
            }
            else if (try_statement -> finally_clause_opt)
            {
                int k;
                for (k = DefiniteBlocks() -> Size() - 1;
                     DefiniteBlocks() -> Block(k) !=
                         DefiniteTrys() -> Block(i);
                     k--);

                assert(k >= 0);

                DefiniteBlocks() -> ReturnPair(k) *=
                    *DefinitelyAssignedVariables();
                break;
            }
        }
    }

    //
    // After execution of a return statement, it is vacuously true
    // that every variable has definitely been assigned and no final
    // variable has been possibly assigned (as nothing is reachable
    // any way).
    //
    *DefinitelyAssignedVariables() = *Universe();
}


void Semantic::DefiniteThrowStatement(Ast *stmt)
{
    AstThrowStatement *throw_statement = (AstThrowStatement *) stmt;

    DefiniteExpression(throw_statement -> expression,
                       *DefinitelyAssignedVariables());

    //
    // Compute the set of variables that are definitely assigned prior to
    // executing this throw statement. Note that this set is only relevant to
    // the method or constructor block containing this statement.
    //
    // TODO: Do we really need this?
    //
    //    DefiniteBlocks() -> TopThrowSet() *= (*DefinitelyAssignedVariables());
    //

    //
    // Compute the set of variables that are possibly assigned prior to
    // executing this throw statement and update the proper enclosing block
    // appropriately.
    //
    // We have a few cases to consider:
    //
    //    1. The throw statement is not contained in a try statement - the
    //       possibly-assigned set is only relevant to the enclosing method
    //       (or constructor) block. If the containing function in question
    //       is a method (i.e., not a constructor) then the definitely
    //       assigned set is updated as if the throw statement was a break
    //       statement out of the method block.
    //
    //    2. The throw statement is enclosed in a try statement main block or
    //       catch clause.
    //
    //        2a. if the nearest try-block that encloses the throw statement
    //            is a main try-block - the possibly-assigned block is
    //            relevant to that main block.
    //        2b. if the nearest try-block that encloses the throw statement
    //            is a catch-block and the try block contains a finally
    //            clause - the possibly-assigned block is relevant to the
    //            catch-block
    //        2c. otherwise, treat the throw statement as if it immediately
    //            followed its containing try statement
    //
    if (DefiniteTrys() -> Size() == 0)
    {
        if (ThisMethod() -> Identity() != control.init_name_symbol)
            // Not a constructor
            DefiniteBlocks() -> ThrowPair(0) *=
                *DefinitelyAssignedVariables();
    }
    else
    {
        for (int i = DefiniteTrys() -> Size() - 1; i >= 0; i--)
        {
            AstTryStatement *try_statement =
                DefiniteTrys() -> TryStatement(i);
            //
            // Is the return statement enclosed in a try main block or catch
            // block that contains a finally clause. Note that a try statement
            // is removed from the DefiniteTrys() before its finally
            // clause is processed. thus, a return statement that is enclosed
            // in a finally clause will appear in an enclosing try statement,
            // if any...
            //
            if (try_statement -> block == DefiniteTrys() -> Block(i))
            {
                // Is the throw statement enclosed in main try block?
                int k;
                for (k = DefiniteBlocks() -> Size() - 1;
                     DefiniteBlocks() -> Block(k) != try_statement -> block;
                     k--);

                assert(k >= 0);

                DefiniteBlocks() -> ThrowPair(k) *=
                    *DefinitelyAssignedVariables();
                break;
            }
            else if (try_statement -> finally_clause_opt)
            {
                int k;
                for (k = DefiniteBlocks() -> Size() - 1;
                     DefiniteBlocks() -> Block(k) !=
                         DefiniteTrys() -> Block(i);
                     k--);

                assert(k >= 0);

                DefiniteBlocks() -> ThrowPair(k) *=
                    *DefinitelyAssignedVariables();
                break;
            }
        }
    }

    //
    // After execution of a throw statement, it is vacuously true
    // that every variable has definitely been assigned and no final
    // variable has been possibly assigned (as nothing is reachable
    // any way).
    //
    *DefinitelyAssignedVariables() = *Universe();
}


void Semantic::DefiniteTryStatement(Ast *stmt)
{
    AstTryStatement *try_statement = (AstTryStatement *) stmt;
    DefiniteTrys() -> Push(try_statement);

    DefinitePair starting_pair(*DefinitelyAssignedVariables());

    AstBlock *try_block_body = try_statement -> block;
    DefiniteBlocks() -> Push(try_block_body);
    DefiniteTrys() -> SetTopBlock(try_block_body);

    for (int j = 0; j < try_block_body -> block_symbol -> NumVariableSymbols();
         j++)
    {
        DefiniteVisibleVariables() ->
            AddElement(try_block_body -> block_symbol -> VariableSym(j));
    }

    BitSet before_try_finals(DefinitelyAssignedVariables() -> du_set);

    DefiniteBlockStatements(try_block_body);

#ifdef DUMP
    if ((control.option.g & JikesOption::VARS) &&
        try_block_body -> NumLocallyDefinedVariables() > 0)
    {
        Coutput << "(6) At Line "
                << lex_stream -> Line(try_block_body -> RightToken())
                << " the range for the following variables end:" << endl
                << endl;
        for (int k = 0; k < try_block_body -> NumLocallyDefinedVariables(); k++)
            Coutput << "    \""
                    << try_block_body -> LocallyDefinedVariable(k) -> Name()
                    << "\"" << endl;
    }
#endif
    DefinitePair &exit_pair =
        DefiniteBlocks() -> TopExitPair(*DefinitelyAssignedVariables());
    BitSet before_catch_finals(exit_pair.du_set),
           possibly_finals_union(exit_pair.du_set);

    //
    // Once we are done with a block, its enclosed local variables are no
    // longer visible.
    //
    for (int l = 0; l < try_block_body -> block_symbol -> NumVariableSymbols();
         l++)
    {
        VariableSymbol *variable =
            try_block_body -> block_symbol -> VariableSym(l);
        int index = variable -> LocalVariableIndex(this);

        BlankFinals() -> RemoveElement(index);
        DefinitelyAssignedVariables() -> ReclaimElement(index);
        before_catch_finals.RemoveElement(index);
        possibly_finals_union.RemoveElement(index);
        DefiniteVisibleVariables() -> RemoveElement(variable);
    }

    DefiniteBlocks() -> Pop();

    //
    // We initilize the variable after_blocks here. It is used to calculate
    // intersection of the set of variables that are definitely assigned by
    // all the blocks: the try block, all the catch blocks, if any, and the
    // finally block, if there is one.
    //
    BitSet after_blocks(DefinitelyAssignedVariables() -> da_set);

    //
    // Recall that the body of the catch blocks must not be
    // processed within the environment of the associated try whose
    // exceptions they are supposed to catch but within the immediate
    // enclosing block (which may itself be a try block).
    //
    for (int i = 0; i < try_statement -> NumCatchClauses(); i++)
    {
        DefinitelyAssignedVariables() -> da_set = starting_pair.da_set;

        //
        // We process the catch block here instead of invoking DefiniteBlock,
        // in order to make sure that the formal parameter (which is declared)
        // inside the block is identified as having been definitely assigned.
        //
        AstCatchClause *clause = try_statement -> CatchClause(i);

        AstBlock *clause_block_body = clause -> block;
        DefiniteBlocks() -> Push(clause_block_body);
        DefiniteTrys() -> SetTopBlock(clause_block_body);

        for (int j = 0;
             j < clause_block_body -> block_symbol -> NumVariableSymbols(); j++)
        {
            DefiniteVisibleVariables() ->
                AddElement(clause_block_body -> block_symbol -> VariableSym(j));
        }

        //
        // The parameter must be added as well
        //
        DefinitelyAssignedVariables() ->
            AddElement(clause -> parameter_symbol -> LocalVariableIndex(this));
        if (control.option.g & JikesOption::VARS)
        {
            VariableSymbol *variable = clause -> parameter_symbol;
            DefiniteBlocks() -> TopLocallyDefinedVariables() ->
                AddElement(variable -> LocalVariableIndex(this));
#ifdef DUMP
            Coutput << "(7) Variable \"" << variable -> Name() << " #"
                    << variable -> LocalVariableIndex(this)
                    << "\" is defined at line "
                    << lex_stream -> Line(clause -> formal_parameter -> LeftToken())
                    << endl;
#endif
        }
        DefinitelyAssignedVariables() -> du_set = before_catch_finals;

        DefiniteBlockStatements(clause_block_body);

#ifdef DUMP
        if ((control.option.g & JikesOption::VARS) &&
            clause_block_body -> NumLocallyDefinedVariables() > 0)
        {
            Coutput << "(8) At Line "
                    << lex_stream -> Line(clause_block_body -> RightToken())
                    << " the range for the following variables end:" << endl
                    << endl;
            for (int l = 0;
                 l < clause_block_body -> NumLocallyDefinedVariables(); l++)
            {
                Coutput << "    \""
                        << clause_block_body -> LocallyDefinedVariable(l) -> Name()
                        << "\"" << endl;
            }
        }
#endif
        //
        // Once we are done with a block, its enclosed local variables are no
        // longer visible.
        //
        for (int k = 0;
             k < clause_block_body -> block_symbol -> NumVariableSymbols(); k++)
        {
            VariableSymbol *variable =
                clause_block_body -> block_symbol -> VariableSym(k);

            BlankFinals() -> RemoveElement(variable -> LocalVariableIndex(this));
            DefinitelyAssignedVariables() ->
                ReclaimElement(variable -> LocalVariableIndex(this));
            DefiniteVisibleVariables() -> RemoveElement(variable);
        }
        //
        // The parameter goes out of scope as well
        //
        BlankFinals() -> RemoveElement(clause -> parameter_symbol ->
                                      LocalVariableIndex(this));
        DefinitelyAssignedVariables() ->
            ReclaimElement(clause -> parameter_symbol -> LocalVariableIndex(this));
        DefiniteVisibleVariables() -> RemoveElement(clause -> parameter_symbol);

        possibly_finals_union *= DefiniteBlocks() ->
            TopExitPair(*DefinitelyAssignedVariables()).du_set;

        DefiniteBlocks() -> Pop();

        //
        // Process the set of variables that were definitely assigned
        // after this catch block
        //
        after_blocks *= DefinitelyAssignedVariables() -> da_set;
    }

    DefinitelyAssignedVariables() -> du_set = possibly_finals_union;
    DefiniteTrys() -> Pop();

    //
    // Like the catch clauses, a finally block must not be processed
    // in the environment of its associated try block but in the
    // environment of its immediate enclosing block.
    //
    if (try_statement -> finally_clause_opt)
    {
        DefinitelyAssignedVariables() -> da_set = starting_pair.da_set;

        DefiniteBlock(try_statement -> finally_clause_opt -> block);

        DefinitelyAssignedVariables() -> da_set += after_blocks;
    }
    else DefinitelyAssignedVariables() -> da_set = after_blocks;
}


void Semantic::DefiniteAssertStatement(Ast *stmt)
{
    AstAssertStatement *assert_statement = (AstAssertStatement *) stmt;

    //
    // Remember what variables were assigned beforehand.
    //
    DefinitePair *before_assert =
        new DefinitePair(*DefinitelyAssignedVariables());

    DefiniteAssignmentSet *after_condition =
        DefiniteBooleanExpression(assert_statement -> condition,
                                  *DefinitelyAssignedVariables());

    if (after_condition)
    {
        //
        // The second expression is evaluated only when the first is false
        // Don't modify da, but update du, as a variable is DU after the assert
        // iff it is DU before the assert and DU after the condition when true.
        //
        *DefinitelyAssignedVariables() = after_condition -> false_pair;
        before_assert -> du_set *= after_condition -> true_pair.du_set;
    }
    else
        before_assert -> du_set *= DefinitelyAssignedVariables() -> du_set;

    if (assert_statement -> message_opt)
        DefiniteExpression(assert_statement -> message_opt,
                           *DefinitelyAssignedVariables());

    //
    // Update the set of variables that are possibly assigned at the time
    // an assert completes abruptly, which affects any definite assignment
    // of catch and finally clauses of enclosing try statements. The assert
    // can only complete abruptly if the condition is not constant true.
    //
    if (! IsConstantTrue(assert_statement -> condition))
    {
        for (int i = DefiniteTrys() -> Size() - 1; i >= 0; i--)
        {
            AstTryStatement *try_statement =
                DefiniteTrys() -> TryStatement(i);
            //
            // Is the assert statement enclosed in a try block or catch block
            // that contains a finally clause? Note that a try statement is
            // removed from the DefiniteTrys() before its finally clause
            // is processed; thus, an assert statement that is enclosed in a
            // finally clause will appear in any enclosing try statement...
            //
            if (try_statement -> block == DefiniteTrys() -> Block(i))
            {
                // In the main try block?
                int k;
                for (k = DefiniteBlocks() -> Size() - 1;
                     DefiniteBlocks() -> Block(k) !=
                         DefiniteTrys() -> Block(i);
                     k--);

                assert(k >= 0);

                DefiniteBlocks() -> ThrowPair(k) *=
                    *DefinitelyAssignedVariables();
                break;
            }
            else if (try_statement -> finally_clause_opt)
            {
                int k;
                for (k = DefiniteBlocks() -> Size() - 1;
                     DefiniteBlocks() -> Block(k) !=
                         DefiniteTrys() -> Block(i);
                     k--);

                assert(k >= 0);

                DefiniteBlocks() -> ThrowPair(k) *=
                    *DefinitelyAssignedVariables();
                break;
            }
        }
     }
 
    //
    // Restore definitely assigned variables to what they were before,
    // since asserts may be disabled
    //
    *DefinitelyAssignedVariables() = *before_assert;

    // harmless if NULL
    delete before_assert;
    delete after_condition;
}


//
// Called for empty statements, class declarations, and misplaced explicit
// constructors.
//
void Semantic::DefiniteEmptyStatement(Ast *stmt)
{
    return;
}


//
// Called only from DefiniteConstructorBody, for this() calls.
//
void Semantic::DefiniteThisCall(AstThisCall *this_call)
{
    for (int i = 0; i < this_call -> NumArguments(); i++)
        DefiniteExpression(this_call -> Argument(i),
                           *DefinitelyAssignedVariables());
}


//
// Called only from DefiniteConstructorBody, for super() calls.
//
void Semantic::DefiniteSuperCall(AstSuperCall *super_call)
{
    if (super_call -> base_opt)
        DefiniteExpression(super_call -> base_opt,
                           *DefinitelyAssignedVariables());
    for (int i = 0; i < super_call -> NumArguments(); i++)
        DefiniteExpression(super_call -> Argument(i),
                           *DefinitelyAssignedVariables());
}


void Semantic::DefiniteMethodBody(AstMethodDeclaration *method_declaration)
{
    int i;
    assert(FinalFields());
    if (method_declaration -> method_body -> EmptyStatementCast())
        return;

#ifdef DUMP
    if (control.option.g & JikesOption::VARS)
        Coutput << "(9) Processing method \""
                << method_declaration -> method_symbol -> Name() << "\" in "
                << ThisType() -> ContainingPackage() -> PackageName()
                << "/" << ThisType() -> ExternalName() << endl;
#endif
    AstBlock *block_body = (AstBlock *) method_declaration -> method_body;

    int size = block_body -> block_symbol -> max_variable_index +
        FinalFields() -> Length();
    Universe() -> Resize(size, BitSet::UNIVERSE);
    int stack_size = method_declaration -> method_symbol -> max_block_depth;
    DefiniteBlocks() = new DefiniteBlockStack(control, stack_size, size);
    DefiniteTrys() = new DefiniteTryStack(stack_size);
    DefinitelyAssignedVariables() -> Resize(size);
    BlankFinals() -> Resize(size, BitSet::EMPTY);

    DefiniteBlocks() -> Push(block_body);

    AstMethodDeclarator *method_declarator =
        method_declaration -> method_declarator;
    for (i = 0; i < method_declarator -> NumFormalParameters(); i++)
    {
        AstVariableDeclarator *formal_declarator =
            method_declarator -> FormalParameter(i) -> formal_declarator;
        DefinitelyAssignedVariables() ->
            AssignElement(formal_declarator -> symbol ->
                          LocalVariableIndex(this));
        if (control.option.g & JikesOption::VARS)
        {
            VariableSymbol *variable = formal_declarator -> symbol;
            DefiniteBlocks() -> TopLocallyDefinedVariables() ->
                AddElement(variable -> LocalVariableIndex(this));
#ifdef DUMP
            Coutput << "(10) Variable \"" << variable -> Name() << " #"
                    << variable -> LocalVariableIndex(this)
                    << "\" is defined at line "
                    << lex_stream -> Line(formal_declarator -> LeftToken())
                    << endl;
#endif
        }

        DefiniteVisibleVariables() ->
            AddElement(formal_declarator -> symbol);
    }

    for (i = 0; i < block_body -> block_symbol -> NumVariableSymbols(); i++)
    {
        VariableSymbol *variable =
            block_body -> block_symbol -> VariableSym(i);
        DefiniteVisibleVariables() -> AddElement(variable);
    }

    DefiniteBlockStatements(block_body);

#ifdef DUMP
    if ((control.option.g & JikesOption::VARS) &&
        block_body -> NumLocallyDefinedVariables() > 0)
    {
        Coutput << "(11) At Line "
                << lex_stream -> Line(block_body -> RightToken())
                << " the range for the following variables end:" << endl
                << endl;
        for (i = 0; i < block_body -> NumLocallyDefinedVariables(); i++)
            Coutput << "    \""
                    << block_body -> LocallyDefinedVariable(i) -> Name()
                    << "\"" << endl;
    }
#endif
    //
    // Remove the variables that went out of scope.
    //
    for (i = 0; i < method_declarator -> NumFormalParameters(); i++)
    {
        VariableSymbol *variable = method_declarator ->
            FormalParameter(i) -> formal_declarator -> symbol;
        DefiniteVisibleVariables() -> RemoveElement(variable);
    }
    for (i = 0; i < block_body -> block_symbol -> NumVariableSymbols(); i++)
    {
        VariableSymbol *variable = block_body -> block_symbol -> VariableSym(i);
        DefiniteVisibleVariables() -> RemoveElement(variable);
    }
    DefiniteBlocks() -> Pop();

    delete DefiniteBlocks();
    DefiniteBlocks() = NULL;
    delete DefiniteTrys();
    DefiniteTrys() = NULL;
    size = FinalFields() -> Length();
    Universe() -> Resize(size);
    DefinitelyAssignedVariables() -> Resize(size);
    BlankFinals() -> Resize(size);
}


void Semantic::DefiniteConstructorBody(AstConstructorDeclaration *constructor_declaration)
{
    int i;
    assert(FinalFields());
#ifdef DUMP
    if (control.option.g & JikesOption::VARS)
        Coutput << "(12) Processing constructor \""
                << constructor_declaration -> constructor_symbol -> Name()
                << "\" in "
                << ThisType() -> ContainingPackage() -> PackageName() << "/"
                << ThisType() -> ExternalName() << endl;
#endif
    AstMethodBody *block_body = constructor_declaration -> constructor_body;

    int size = block_body -> block_symbol -> max_variable_index +
        FinalFields() -> Length();
    Universe() -> Resize(size, BitSet::UNIVERSE);
    int stack_size =
        constructor_declaration -> constructor_symbol -> max_block_depth;
    DefiniteBlocks() = new DefiniteBlockStack(control, stack_size, size);
    DefiniteTrys() = new DefiniteTryStack(stack_size);
    DefinitelyAssignedVariables() -> Resize(size);
    BlankFinals() -> Resize(size, BitSet::EMPTY);

    DefiniteBlocks() -> Push(block_body);

    AstMethodDeclarator *constructor_declarator =
        constructor_declaration -> constructor_declarator;
    for (i = 0; i < constructor_declarator -> NumFormalParameters(); i++)
    {
        AstVariableDeclarator *formal_declarator =
            constructor_declarator -> FormalParameter(i) -> formal_declarator;
        DefinitelyAssignedVariables() ->
            AddElement(formal_declarator -> symbol -> LocalVariableIndex(this));
        if (control.option.g & JikesOption::VARS)
        {
            VariableSymbol *variable = formal_declarator -> symbol;
            DefiniteBlocks() -> TopLocallyDefinedVariables() ->
                AddElement(variable -> LocalVariableIndex(this));
#ifdef DUMP
            Coutput << "(13) Variable \"" << variable -> Name() << " #"
                    << variable -> LocalVariableIndex(this)
                    << "\" is defined at line "
                    << lex_stream -> Line(formal_declarator -> LeftToken())
                    << endl;
#endif
        }

        DefiniteVisibleVariables() -> AddElement(formal_declarator -> symbol);
    }

    for (i = 0; i < block_body -> block_symbol -> NumVariableSymbols(); i++)
    {
        VariableSymbol *variable = block_body -> block_symbol -> VariableSym(i);
        DefiniteVisibleVariables() -> AddElement(variable);
    }

    if (block_body -> explicit_constructor_opt)
    {
        if (block_body -> explicit_constructor_opt -> ThisCallCast())
            DefiniteThisCall((AstThisCall *) block_body ->
                             explicit_constructor_opt);
        else DefiniteSuperCall((AstSuperCall *) block_body ->
                               explicit_constructor_opt);
    }
    DefiniteBlockStatements(block_body);

#ifdef DUMP
    if ((control.option.g & JikesOption::VARS) &&
        block_body -> NumLocallyDefinedVariables() > 0)
    {
        Coutput << "(14) At Line "
                << lex_stream -> Line(block_body -> RightToken())
                << " the range for the following variables end:" << endl
                << endl;
        for (int j = 0; j < block_body -> NumLocallyDefinedVariables(); j++)
            Coutput << "    \""
                    << block_body -> LocallyDefinedVariable(j) -> Name()
                    << "\"" << endl;
    }
#endif
    //
    // Compute the set of finals that has definitely been assigned in this
    // constructor. Also remove the variables that went out of scope.
    //
    *DefinitelyAssignedVariables() = DefiniteBlocks() ->
        TopExitPair(*DefinitelyAssignedVariables());
    for (i = 0; i < constructor_declarator -> NumFormalParameters(); i++)
    {
        VariableSymbol *variable = constructor_declarator ->
            FormalParameter(i) -> formal_declarator -> symbol;
        DefiniteVisibleVariables() -> RemoveElement(variable);
    }
    for (i = 0; i < block_body -> block_symbol -> NumVariableSymbols(); i++)
    {
        VariableSymbol *variable = block_body -> block_symbol -> VariableSym(i);
        DefiniteVisibleVariables() -> RemoveElement(variable);
    }
    DefiniteBlocks() -> Pop();

    delete DefiniteBlocks();
    DefiniteBlocks() = NULL;
    delete DefiniteTrys();
    DefiniteTrys() = NULL;
    size = FinalFields() -> Length();
    Universe() -> Resize(size);
    DefinitelyAssignedVariables() -> Resize(size);
    BlankFinals() -> Resize(size);
}


void Semantic::DefiniteBlockInitializer(AstBlock *block_body, int stack_size)
{
    int i;
    assert(FinalFields());
#ifdef DUMP
    if (control.option.g & JikesOption::VARS)
        Coutput << "(15) Processing Initializer block in "
                << ThisType() -> ContainingPackage() -> PackageName() << "/"
                << ThisType() -> ExternalName() << endl;
#endif
    int size = block_body -> block_symbol -> max_variable_index +
        FinalFields() -> Length();
    Universe() -> Resize(size, BitSet::UNIVERSE);
    // +1 for absent method block
    DefiniteBlocks() = new DefiniteBlockStack(control, stack_size + 1, size);
    DefiniteTrys() = new DefiniteTryStack(stack_size + 1);
    DefinitelyAssignedVariables() -> Resize(size);
    BlankFinals() -> Resize(size, BitSet::EMPTY);

    DefiniteBlocks() -> Push(NULL); // No method available
    DefiniteBlocks() -> Push(block_body);

    for (i = 0; i < block_body -> block_symbol -> NumVariableSymbols(); i++)
    {
        VariableSymbol *variable = block_body -> block_symbol -> VariableSym(i);
        DefiniteVisibleVariables() -> AddElement(variable);
    }

    DefiniteBlockStatements(block_body);

#ifdef DUMP
    if ((control.option.g & JikesOption::VARS) &&
        block_body -> NumLocallyDefinedVariables() > 0)
    {
        Coutput << "(16) At Line "
                << lex_stream -> Line(block_body -> RightToken())
                << " the range for the following variables end:" << endl
                << endl;
        for (i = 0; i < block_body -> NumLocallyDefinedVariables(); i++)
            Coutput << "    \""
                    << block_body -> LocallyDefinedVariable(i) -> Name()
                    << "\"" << endl;
    }
#endif
    //
    // For each final that has definitely or possibly been assigned a value
    // in this block, mark it appropriately. Also remove the variables that
    // went out of scope.
    //
    *DefinitelyAssignedVariables() = DefiniteBlocks() ->
        TopExitPair(*DefinitelyAssignedVariables());
    for (i = 0; i < block_body -> block_symbol -> NumVariableSymbols(); i++)
    {
        VariableSymbol *variable = block_body -> block_symbol -> VariableSym(i);
        DefiniteVisibleVariables() -> RemoveElement(variable);
    }
    DefiniteBlocks() -> Pop();
    // remove NULL that was pushed to indicate that no method is available
    DefiniteBlocks() -> Pop();

    delete DefiniteBlocks();
    DefiniteBlocks() = NULL;
    delete DefiniteTrys();
    DefiniteTrys() = NULL;
    size = FinalFields() -> Length();
    Universe() -> Resize(size);
    DefinitelyAssignedVariables() -> Resize(size);
    BlankFinals() -> Resize(size);
}


void Semantic::DefiniteFieldInitializer(AstVariableDeclarator *variable_declarator)
{
    assert(FinalFields());

    DefiniteVariableInitializer(variable_declarator);
    if (variable_declarator -> symbol -> ACC_FINAL())
    {
        DefinitelyAssignedVariables() ->
            AssignElement(variable_declarator -> symbol ->
                          LocalVariableIndex());
    }
}


void Semantic::DefiniteSetup()
{
    //
    // Compute the set of final variables (all fields in an interface are
    // final) in this type. Then process all initializers.
    //
    assert(! FinalFields());
    TypeSymbol *this_type = ThisType();
    FinalFields() =
        new Tuple<VariableSymbol *> (this_type -> NumVariableSymbols());
    int size = 0;
    for (int i = 0; i < this_type -> NumVariableSymbols(); i++)
    {
        VariableSymbol *variable_symbol = this_type -> VariableSym(i);
        if (variable_symbol -> ACC_FINAL() &&
            ! variable_symbol -> IsSynthetic())
        {
            variable_symbol -> SetLocalVariableIndex(size++);
            FinalFields() -> Next() = variable_symbol;
        }
    }
    Universe() = new DefinitePair(size, BitSet::UNIVERSE);
    DefiniteFinalAssignments() = new DefiniteFinalAssignmentStack();
    DefiniteVisibleVariables() = new SymbolSet(size);
    DefinitelyAssignedVariables() = new DefinitePair(size);
    BlankFinals() = new BitSet(size, BitSet::EMPTY);
    for (int j = 0; j < size; j++)
    {
        VariableSymbol *final_var = (*FinalFields())[j];
        if (! final_var -> declarator -> variable_initializer_opt)
            BlankFinals() -> AddElement(j);
        DefiniteVisibleVariables() -> AddElement(final_var);
    }
}


void Semantic::DefiniteCleanUp()
{
    assert (FinalFields());
    delete FinalFields();
    FinalFields() = NULL;
    delete Universe();
    delete DefinitelyAssignedVariables();
    delete DefiniteFinalAssignments();
    delete DefiniteVisibleVariables();
    delete BlankFinals();
}

#ifdef HAVE_JIKES_NAMESPACE
} // Close namespace Jikes block
#endif
